## 01、Java 集合框架概述

### 1.1、集合框架与数组的对比及概述

> 1、集合的使用场景

![](https://img-blog.csdnimg.cn/img_convert/47d7501e379e9554f1c0e32f16d4aa19.png)
![](https://img-blog.csdnimg.cn/img_convert/7dd14b25935d46725bf3e42f9c47a47a.png)

### 1.2、集合框架涉及到的API

* Java 集合可分为 `Collection`和 `Map`两种体系
  - `Collection`接口：单列数据，定义了存取一组对象的方法的集合
    + `List`：元素有序、可重复的集合
    + `Set`：元素无序、不可重复的集合
  - `Map`接口：双列数据，保存具有映射关系"key-value对"的集合

> 1、 **Collection接口继承树**

![](https://img-blog.csdnimg.cn/img_convert/4a9d3171541866ba77e2291ce41e9962.png)

> 2、 **Map接口继承树**

![](https://img-blog.csdnimg.cn/img_convert/a1fdb6d75598e87a224697d12c2c2bcf.png)

## 02、Collection接口方法

* Collection 接口是List、Set 和Queue 接口的父接口，该接口里定义的方法既可用于操作Set 集合，也可用于操作List 和Queue 集合。
* JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。
* 在Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成Object 类型处理；从JDK 5.0 增加了 **泛型**以后，Java 集合可以记住容器中对象的数据类型。

### 2.2、Collection接口中的常用方法1

1. 添加
  - add(Objec tobj)
  - addAll(Collection coll)
2. 获取有效元素的个数
  - int size()
3. 清空集合
  - void clear()
4. 是否是空集合
  - boolean isEmpty()
5. 是否包含某个元素
  - boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象
  - boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。
6. 删除
  - boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素
  - boolean removeAll(Collection coll)：取当前集合的差集
7. 取两个集合的交集
  - boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c
8. 集合是否相等
  - boolean equals(Object obj)
9. 转成对象数组
  - Object[] toArray()
10. 获取集合对象的哈希值
  - hashCode()
11. 遍历
  - iterator()：返回迭代器对象，用于集合遍历

```java
import org.junit.Test;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;

public class CollectionTest {

    @Test
    public void test1(){
        Collection coll = new ArrayList();

        coll.add("AA");
        coll.add("BB");
        coll.add(123);
        coll.add(new Date());

        System.out.println(coll.size());

        Collection coll1 = new ArrayList();
        coll1.add(456);
        coll1.add("CC");
        coll.addAll(coll1);

        System.out.println(coll.size());
        System.out.println(coll);

        coll.clear();

        System.out.println(coll.isEmpty());
    }
}
```

### 2.3、Collection接口中的常用方法2

> 1、Person类

```java
import java.util.Objects;

public class Person {

    private String name;
    private int age;

    public Person() {
        super();
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("Person equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {

        return Objects.hash(name, age);
    }
}
```

> 2、测试类

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

public class CollectinoTest {

    @Test
    public void test(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);

        coll.add(new Person("Jerry",20));

        coll.add(new String("Tom"));
        coll.add(false);

        boolean contains = coll.contains(123);
        System.out.println(contains);
        System.out.println(coll.contains(new String("Tam")));

        System.out.println(coll.contains(new Person("Jerry",20)));

        Collection coll1 = Arrays.asList(123,4567);
        System.out.println(coll.containsAll(coll1));
    }

}
```

### 2.4、Collection接口中的常用方法3

> 1、Person类

```java
import java.util.Objects;

public class Person {

    private String name;
    private int age;

    public Person() {
        super();
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("Person equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {

        return Objects.hash(name, age);
    }
}
```

> 2、测试类

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

public class CollectinoTest {

    @Test
    public void test2(){

        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        coll.remove(1234);
        System.out.println(coll);

        coll.remove(new Person("Jerry",20));
        System.out.println(coll);

        Collection coll1 = Arrays.asList(123,456);
        coll.removeAll(coll1);
        System.out.println(coll);
    }

    @Test
    public void test3(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        Collection coll1 = new ArrayList();
        coll1.add(456);
        coll1.add(123);
        coll1.add(new Person("Jerry",20));
        coll1.add(new String("Tom"));
        coll1.add(false);

        System.out.println(coll.equals(coll1));
    }

}
```

### 2.5、Collection接口中的常用方法4

> 1、Person类

```java
import java.util.Objects;

public class Person {

    private String name;
    private int age;

    public Person() {
        super();
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("Person equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {

        return Objects.hash(name, age);
    }
}
```

> 2、测试类

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

public class CollectinoTest {

    @Test
    public void test4(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        System.out.println(coll.hashCode());

        Object[] arr = coll.toArray();
        for(int i = 0;i < arr.length;i++){
            System.out.println(arr[i]);
        }

        List<String> list = Arrays.asList(new String[]{"AA", "BB", "CC"});
        System.out.println(list);

        List arr1 = Arrays.asList(123, 456);
        System.out.println(arr1);

        List arr2 = Arrays.asList(new int[]{123, 456});
        System.out.println(arr2.size());

        List arr3 = Arrays.asList(new Integer[]{123, 456});
        System.out.println(arr3.size());

    }
}
```

## 03、Iterator迭代器接口

* Iterator对象称为迭代器(设计模式的一种)，主要用于遍历Collection 集合中的元素。
* GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。 **迭代器模式，就是为容器而生**。类似于"公交车上的售票员"、"火车上的乘务员"、"空姐"。
* Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。
* **Iterator 仅用于遍历集合**，Iterator本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。
* **集合对象每次调用iterator()方法都得到一个全新的迭代器对象**，默认游标都在集合的第一个元素之前。

![](https://img-blog.csdnimg.cn/img_convert/92824284e855a3c578bcd9a977bc528c.png)

### 3.1、使用Iterator遍历Collection

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class IteratorTest {

    @Test
    public void test(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        Iterator iterator = coll.iterator();

        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

### 3.2、迭代器Iterator的执行原理

![](https://img-blog.csdnimg.cn/img_convert/e22bd60a120c0355cbb2ae3601442cb7.png)

### 3.3、Iterator遍历集合的两种错误写法

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class IteratorTest {

    @Test
    public void test2(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        while(coll.iterator().hasNext()){
            System.out.println(coll.iterator().next());
        }
    }
}
```

### 3.4、Iterator迭代器remove()的使用

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class IteratorTest {

    @Test
    public void test3(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        Iterator iterator = coll.iterator();
        while(iterator.hasNext()){

            Object obj = iterator.next();
            if("Tom".equals(obj)){
                iterator.remove();

            }
        }

        iterator = coll.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }

    }
}
```

> 注意：

* Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。
* **如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException**。

### 3.5、新特性foreach循环遍历集合或数组

* Java 5.0 提供了foreach循环迭代访问Collection和数组。
* 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。
* 遍历集合的底层调用Iterator完成操作。
* foreach还可以用来遍历数组。

![](https://img-blog.csdnimg.cn/img_convert/7f424cc6c34bd887f20adac6cd9afa0f.png)

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

public class ForTest {

    @Test
    public void test(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        for(Object obj : coll){
            System.out.println(obj);
        }
    }

    @Test
    public void test2(){
        int[] arr = new int[]{1,2,3,4,5,6};

        for(int i : arr){
            System.out.println(i);
        }
    }

    @Test
    public void test3(){
        String[] arr = new String[]{"SS","KK","RR"};

        for(String s : arr){
            s = "HH";
        }

        for(int i = 0;i < arr.length;i++){
            System.out.println(arr[i]);
        }
    }
}
```

## 04、Collection子接口之一：List接口

* 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组
* List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。
* List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
* JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。

### 4.1、List接口常用实现类的对比

### 4.2、ArrayList的源码分析

* ArrayList是List 接口的典型实现类、主要实现类
* 本质上，ArrayList是对象引用的一个"变长"数组

### 4.3、LinkedList的源码分析

* 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高
* LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。

![](https://img-blog.csdnimg.cn/img_convert/1694eedac8f9664aa96cf0a673679e94.png)

### 4.4、Vector的源码分析

* Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。
* 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。

### 4.5、List接口中的常用方法测试

> List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。

* `void add(intindex, Object ele)`:在index位置插入ele元素
* `boolean addAll(int index, Collection eles)`:从index位置开始将eles中的所有元素添加进来
* `Object get(int index)`:获取指定index位置的元素
* `int indexOf(Object obj)`:返回obj在集合中首次出现的位置
* `int lastIndexOf(Object obj)`:返回obj在当前集合中末次出现的位置
* `Object remove(int index)`:移除指定index位置的元素，并返回此元素
* `Object set(int index, Object ele)`:设置指定index位置的元素为ele
* `List subList(int fromIndex, int toIndex)`:返回从fromIndex到toIndex位置的子集合

```java
import org.junit.Test;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

public class ListTest {

    @Test
    public void test3(){
        ArrayList list = new ArrayList();
        list.add(123);
        list.add(456);
        list.add("AA");

        Iterator iterator = list.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }

        System.out.println("***************");

        for(Object obj : list){
            System.out.println(obj);
        }

        System.out.println("***************");

        for(int i = 0;i < list.size();i++){
            System.out.println(list.get(i));
        }
    }

    @Test
    public void tets2(){
        ArrayList list = new ArrayList();
        list.add(123);
        list.add(456);
        list.add("AA");
        list.add(new Person("Tom",12));
        list.add(456);

        int index = list.indexOf(4567);
        System.out.println(index);

        System.out.println(list.lastIndexOf(456));

        Object obj = list.remove(0);
        System.out.println(obj);
        System.out.println(list);

        list.set(1,"CC");
        System.out.println(list);

        List subList = list.subList(2, 4);
        System.out.println(subList);
        System.out.println(list);
    }

    @Test
    public void test(){
        ArrayList list = new ArrayList();
        list.add(123);
        list.add(456);
        list.add("AA");
        list.add(new Person("Tom",12));
        list.add(456);

        System.out.println(list);

        list.add(1,"BB");
        System.out.println(list);

        List list1 = Arrays.asList(1, 2, 3);
        list.addAll(list1);

        System.out.println(list.size());

        System.out.println(list.get(2));

    }
}
```

### 4.6、List的一个面试小题

> 1、面试题1

请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?

> 2、面试题2

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

public class ListEver {

    @Test
    public void testListRemove() {
        List list = new ArrayList();
        list.add(1);
        list.add(2);
        list.add(3);
        updateList(list);
        System.out.println(list);
    }

    private void updateList(List list) {

        list.remove(new Integer(2));
    }
}
```

## 05、Collection子接口之二：Set接口

* Set接口是Collection的子接口，set接口没有提供额外的方法
* Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。
* **Set 判断两个对象是否相同不是使用 `==` 运算符，而是根据 `equals()` 方法*

### 5.1、Set接口实现类的对比

### 5.2、Set的无序性与不可重复性的理解

> 1、测试类

```java
import org.junit.Test;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class SetTest {

    @Test
    public void test(){
        Set set = new HashSet();
        set.add(123);
        set.add(456);
        set.add("fgd");
        set.add("book");
        set.add(new User("Tom",12));
        set.add(new User("Tom",12));
        set.add(129);

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

> 2、User类

```java
public class User{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("User equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }
}
```

### 5.3、HashSet中元素的添加过程

* `HashSet`是 `Set` 接口的典型实现，大多数时候使用Set 集合时都使用这个实现类。
* `HashSe`t按 `Hash` 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。
* `HashSet`具有以下特点：不能保证元素的排列顺序
  - **`HashSet` 不是线程安全的**
  - **集合元素可以是 `null`**
* **底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128...等）**
* **`HashSet` 集合判断两个元素相等的标准：两个对象通过 `hashCode()` 方法比较相等，并且两个对象的 `equals()` 方法返回值也相等。**
* 对于存放在 `Set`容器中的对象，对应的类一定要重写 `equals()`和 `hashCode(Object obj)`方法，以实现对象相等规则。即：" **相等的对象必须具有相等的散列码**"。

![](https://img-blog.csdnimg.cn/img_convert/9cadfe3cd3721e9c7ba5f414f57434ec.png)

### 5.4、关于hashCode()和equals()的重写

#### 5.4.1、重写hashCode() 方法的基本原则

* 在程序运行时，同一个对象多次调用 `hashCode()`方法应该返回相同的值。
* 当两个对象的 `equals()`方法比较返回 `true`时，这两个对象的 `hashCode()`方法的返回值也应相等。
* 对象中用作 `equals()` 方法比较的 `Field`，都应该用来计算 `hashCode`值。

#### 5.4.2、重写equals() 方法的基本原则

> 以自定义的Customer类为例，何时需要重写equals()？

* 当一个类有自己特有的"逻辑相等"概念,当改写equals()的时候，总是要改写 `hashCode()`，根据一个类的 `equals`方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据 `Object.hashCode()`方法，它们仅仅是两个对象。
* 因此，违反了" **相等的对象必须具有相等的散列码**"。
* 结论：复写 `equals`方法的时候一般都需要同时复写 `hashCode`方法。通常参与计算 `hashCod`e的对象的属性也应该参与到 `equals()`中进行计算。

#### 5.4.3、Eclipse/IDEA工具里hashCode()的重写

> 以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？

* 选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的"冲突"就越少，查找起来效率也会提高。（减少冲突）
* 并且31只占用5bits,相乘造成数据溢出的概率较小。
* 31可以由i*31== (i<

### 5.5、LinkedHashSet的使用

* `LinkedHashSet`是 `HashSet`的子类
* `LinkedHashSet`根据元素的 `hashCode`值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以 **插入顺序保存**的。
* **`LinkedHashSet` 插入性能略低于 `HashSet`**，但在迭代访问Set 里的全部元素时有很好的性能。
* LinkedHashSet不允许集合元素重复。

![](https://img-blog.csdnimg.cn/img_convert/142499a55331e1ce03aa23593f2f66a7.png)

> 1、测试类

```java
import org.junit.Test;

import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

public class SetTest {

    @Test
    public void test2(){
        Set set = new LinkedHashSet();
        set.add(456);
        set.add(123);
        set.add(123);
        set.add("AA");
        set.add("CC");
        set.add(new User("Tom",12));
        set.add(new User("Tom",12));
        set.add(129);

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

> 2、User类

```java
public class User{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("User equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }
}
```

### 5.6、TreeSet的自然排序

* `TreeSet`是 `SortedSet`接口的实现类， `TreeSet`可以确保集合元素处于排序状态。
* `TreeSet`底层使用 **红黑树**结构存储数据
* 新增的方法如下：(了解)
  - `Comparator comparator()`
  - `Object first()`
  - `Object last()`
  - `Object lower(Object e)`
  - `Object higher(Object e)`
  - `SortedSet subSet(fromElement, toElement)`
  - `SortedSet headSet(toElement)`
  - `SortedSet tailSet(fromElement)`
* `TreeSet`两种排序方法： **自然排序和定制排序**。默认情况下， `TreeSet`采用自然排序。
* `TreeSet`和后面要讲的 `TreeMap`采用红黑树的存储结构
* 特点：有序，查询速度比 `List`快
* **自然排序**： `TreeSet`会调用集合元素的 `compareTo(Object obj)`方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。
* **如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable 接口**。
  - 实现 `Comparable` 的类必须实现 `compareTo(Object obj)`方法，两个对象即通过 `compareTo(Object obj)`方法的返回值来比较大小。
* `Comparable` 的典型实现：
  - `BigDecimal&#x3001;BigInteger`以及所有的数值型对应的包装类：按它们对应的数值大小进行比较
  - `Character`：按字符的unicode值来进行比较
  - `Boolean`：true 对应的包装类实例大于false 对应的包装类实例
  - `String`：按字符串中字符的unicode 值进行比较
  - `Date&#x3001;Time`：后边的时间、日期比前面的时间、日期大
* `&#x5411;TreeSet`中添加元素时，只有第一个元素无须比较 `compareTo()`方法，后面添加的所有元素都会调用 `compareTo()`方法进行比较。
* **因为只有相同类的两个实例才会比较大小，所以向 `TreeSet` 中添加的应该是同一个类的对象**。
* 对于 `TreeSet`集合而言，它 **判断两个对象是否相等的唯一标准**是：两个对象通过 `compareTo(Object obj)`方法比较返回值。
* 当需要把一个对象放入 `TreeSet`中，重写该对象对应的 `equals()`方法时，应保证该方法与 `compareTo(Object obj)` 方法有一致的结果：如果两个对象通过 `equals()`方法比较返回true，则通过 `compareTo(Object obj)`方法比较应返回0。否则，让人难以理解。

> 红黑树

![](https://img-blog.csdnimg.cn/img_convert/dceafcf11f36434b2fba8584a0202e3a.png)

> 1、测试类

```java
import org.junit.Test;

import java.util.Iterator;
import java.util.TreeSet;

public class TreeSetTest {

    @Test
    public void test() {
        TreeSet set = new TreeSet();

        set.add(new User("Tom",12));
        set.add(new User("Jerry",32));
        set.add(new User("Jim",2));
        set.add(new User("Mike",65));
        set.add(new User("Jack",33));
        set.add(new User("Jack",56));

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

> 2、User类

```java
public class User implements Comparable{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("User equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    @Override
    public int compareTo(Object o) {
        if (o instanceof User) {
            User user = (User) o;

            int compare = -this.name.compareTo(user.name);
            if(compare != 0){
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        } else {
            throw new RuntimeException("输入的类型不匹配");
        }
    }
}
```

### 5.7、TreeSet的定制排序

* `TreeSet`的 **自然排序**要求元素所属的类实现 `Comparable`接口，如果元素所属的类没有实现 `Comparable`接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过 `Comparator`接口来实现。需要重写 `compare(T o1,T o2`)方法。
* 利用 `int compare(T o1,T o2)`方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。
* 要实现 **定制排序**，需要将实现 `Comparator`接口的实例作为形参传递给 `TreeSe`t的构造器。
* 此时，仍然只能向 `TreeSet`中添加类型相同的对象。否则发生 `ClassCastException`异常。
* 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。

> 1、测试类

```java
import org.junit.Test;

import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

public class TreeSetTest {

    @Test
    public void tets2(){
        Comparator com = new Comparator() {

            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof User && o2 instanceof User){
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    return Integer.compare(u1.getAge(),u2.getAge());
                }else{
                    throw new RuntimeException("输入的数据类型不匹配");
                }
            }
        };

        TreeSet set = new TreeSet(com);
        set.add(new User("Tom",12));
        set.add(new User("Jerry",32));
        set.add(new User("Jim",2));
        set.add(new User("Mike",65));
        set.add(new User("Mary",33));
        set.add(new User("Jack",33));
        set.add(new User("Jack",56));

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

> 2、User类

```java
public class User implements Comparable{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("User equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    @Override
    public int compareTo(Object o) {
        if (o instanceof User) {
            User user = (User) o;

            int compare = -this.name.compareTo(user.name);
            if(compare != 0){
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        } else {
            throw new RuntimeException("输入的类型不匹配");
        }
    }
}
```

### 5.8、TreeSet的课后练习

![](https://img-blog.csdnimg.cn/img_convert/bf48149ea63b1be479da1a19db027fb1.png)

> 1、MyDate类

```java

public class MyDate implements Comparable{
    private int year;
    private int month;
    private int day;

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    public int getMonth() {
        return month;
    }

    public void setMonth(int month) {
        this.month = month;
    }

    public int getDay() {
        return day;
    }

    public void setDay(int day) {
        this.day = day;
    }

    public MyDate() {
    }

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    @Override
    public String toString() {
        return "MyDate{" +
                "year=" + year +
                ", month=" + month +
                ", day=" + day +
                '}';
    }

    @Override
    public int compareTo(Object o) {
        if(o instanceof MyDate){
            MyDate m = (MyDate)o;

            int minusYear = this.getYear() - m.getYear();
            if(minusYear != 0){
                return minusYear;
            }

            int minusMonth = this.getMonth() - m.getMonth();
            if(minusMonth != 0){
                return minusMonth;
            }

            return this.getDay() - m.getDay();
        }

        throw new RuntimeException("传入的数据类型不一致！");

    }
}
```

> 2、Employee类

```java

public class Employee implements Comparable{
    private String name;
    private int age;
    private MyDate birthday;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public MyDate getBirthday() {
        return birthday;
    }

    public void setBirthday(MyDate birthday) {
        this.birthday = birthday;
    }

    public Employee() {
    }

    public Employee(String name, int age, MyDate birthday) {
        this.name = name;
        this.age = age;
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", birthday=" + birthday +
                '}';
    }

    @Override
    public int compareTo(Object o){
        if(o instanceof Employee){
            Employee e = (Employee)o;
            return this.name.compareTo(e.name);
        }

        throw new RuntimeException("传入的数据类型不一致");
    }
}
```

> 3、测试类

```java
import org.junit.Test;

import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

public class EmployeeTest {

    @Test
    public void test2(){
        TreeSet set = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof Employee && o2 instanceof Employee){
                    Employee e1 = (Employee)o1;
                    Employee e2 = (Employee)o2;

                    MyDate b1 = e1.getBirthday();
                    MyDate b2 = e2.getBirthday();

                    return b1.compareTo(b2);
                }

                throw new RuntimeException("传入的数据类型不一致！");
            }
        });

        Employee e1 = new Employee("wangxianzhi",41,new MyDate(334,5,4));
        Employee e2 = new Employee("simaqian",43,new MyDate(-145,7,12));
        Employee e3 = new Employee("yanzhenqin",44,new MyDate(709,5,9));
        Employee e4 = new Employee("zhangqian",51,new MyDate(-179,8,12));
        Employee e5 = new Employee("quyuan",21,new MyDate(-340,12,4));

        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);

        Iterator iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }

    @Test
    public void test(){
        TreeSet set = new TreeSet();

        Employee e1 = new Employee("wangxianzhi",41,new MyDate(334,5,4));
        Employee e2 = new Employee("simaqian",43,new MyDate(-145,7,12));
        Employee e3 = new Employee("yanzhenqin",44,new MyDate(709,5,9));
        Employee e4 = new Employee("zhangqian",51,new MyDate(-179,8,12));
        Employee e5 = new Employee("quyuan",21,new MyDate(-340,12,4));

        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);

        Iterator iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

### 5.9、Set课后两道面试题

> 练习：在List内去除重复数字值，要求尽量简单

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

public class CollectionTest {

    public static List duplicateList(List list) {
        HashSet set = new HashSet();
        set.addAll(list);
        return new ArrayList(set);
    }
    @Test
    public void test2(){
        List list = new ArrayList();
        list.add(new Integer(1));
        list.add(new Integer(2));
        list.add(new Integer(2));
        list.add(new Integer(4));
        list.add(new Integer(4));
        List list2 = duplicateList(list);
        for (Object integer : list2) {
            System.out.println(integer);
        }
    }
}
```

> 2、面试题

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

public class CollectionTest {

    @Test
    public void test3(){
        HashSet set = new HashSet();
        Person p1 = new Person(1001,"AA");
        Person p2 = new Person(1002,"BB");

        set.add(p1);
        set.add(p2);
        System.out.println(set);

        p1.name = "CC";
        set.remove(p1);
        System.out.println(set);
        set.add(new Person(1001,"CC"));
        System.out.println(set);
        set.add(new Person(1001,"AA"));
        System.out.println(set);

    }
}
```

> Person类

```java
public class Person {

    int id;
    String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public Person() {

    }

    @Override
    public String toString() {
        return "Person{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;

        if (id != person.id) return false;
        return name != null ? name.equals(person.name) : person.name == null;
    }

    @Override
    public int hashCode() {
        int result = id;
        result = 31 * result + (name != null ? name.hashCode() : 0);
        return result;
    }
}
```

## 06、Map接口

![](https://img-blog.csdnimg.cn/img_convert/34101a405fcfc7c089f0165cb4c9545e.png)

### 6.1、Map接口及其多个实现类的对比

```java
import org.junit.Test;

import java.util.HashMap;
import java.util.Map;

public class MapTest {
    @Test
    public void test(){
        Map map = new HashMap();

        map.put(null,123);
    }
}
```

### 6.2、Map中存储的key-value的特点

* `Map`与 `Collection`并列存在。用于保存具有映射关系的数据: `key-value`
* `Map`中的 `key`和 `value`都可以是任何引用类型的数据
* `Map` 中的 `key` 用 `Set`来存放，不允许重复，即同一个 `Map` 对象所对应的类，须重写 `hashCode()`和 `equals()`方法
* 常用 `String`类作为 `Ma`p的"键"
* `key`和 `value`之间存在单向一对一关系，即通过指定的 `key`总能找到唯一的、确定的 `value`
* `Map`接口的常用实现类： `HashMap&#x3001;TreeMap&#x3001;LinkedHashMap`和 `Properties`。其中， `HashMap`是 `Map`接口使用频率最高的实现类

![](https://img-blog.csdnimg.cn/img_convert/8be1971cf0f098a6512b9668871c3541.png)

### 6.3、Map实现类之一：HashMap

* **`HashMap` 是 `Map` 接口使用频率最高的实现类**。
* 允许使用 `null`键和 `null`值，与 `HashSet`一样，不保证映射的顺序。
* 所有的 `key`构成的集合是 `Set`:无序的、不可重复的。所以， `key`所在的类要重写： `equals()`和 `hashCode()`
* 所有的 `value`构成的集合是 `Collection`:无序的、可以重复的。所以， `value`所在的类要重写： `equals()`
* 一个 `key-value`构成一个 `entry`
* 所有的 `entry`构成的集合是 `Set`:无序的、不可重复的
* `HashMap`判断两个 `key`相等的标准是：两个 `key`通过 `equals()`方法返回 `true`， `hashCode`值也相等。
* `HashMap`判断两个 `value`相等的标准是：两个 `value` 通过 `equals()`方法返回 `true`。

### 6.4、HashMap的底层实现原理

> **JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)**
**JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。**

![](https://img-blog.csdnimg.cn/img_convert/58c89db281ee84d93098a4f043dd3856.png)
![](https://img-blog.csdnimg.cn/img_convert/b2aebd46ed8d41111825cd15ac2a3be6.png)

> HashMap源码中的重要常量

#### 6.4.1、HashMap在JDK7中的底层实现原理

* `HashMap&#x7684;`内部存储结构其实是 **数组和链表的结合**。当实例化一个 `HashMap`时，系统会创建一个长度为 `Capacity`的 `Entry`数组，这个长度在哈希表中被称为容量(`Capacity`)，在这个数组中可以存放元素的位置我们称之为"桶"(`bucket`)，每个 `bucket`都有自己的索引，系统可以根据索引快速的查找 `bucket`中的元素。
* 每个 `bucket`中存储一个元素，即一个 `Entry`对象，但每一个 `Entry`对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个 `Entry`链。而且新添加的元素作为链表的 `head`。
* 添加元素的过程：
  - 向 `HashMap`中添加 `entry1(key&#xFF0C;value)`，需要首先计算 `entry1`中 `key`的哈希值(根据 `key`所在类的 `hashCode()`计算得到)，此哈希值经过处理以后，得到在底层 `Entry[]`数组中要存储的位置 `i`。
  - 如果位置 `i`上没有元素，则 `entry1`直接添加成功。
  - 如果位置 `i`上已经存在 `entry2`(或还有链表存在的 `entry3&#xFF0C;entry4`)，则需要通过循环的方法，依次比较 `entry1`中 `key`的 `hash`值和其他的 `entry`的 `hash`值。
  - 如果彼此 `hash`值不同，则直接添加成功。
  - 如果 `hash`值相同，继续比较二者是否 `equals`。如果返回值为 `true`，则使用 `entry1`的 `value`去替换 `equals`为 `true`的 `entry`的 `value`。
  - 如果遍历一遍以后，发现所有的 `equals`返回都为 `false`,则 `entry1`仍可添加成功。 `entry1`指向原有的 `entry`元素。

#### 6.4.2、HashMap在JDK8中的底层实现原理

* `HashMap`的内部存储结构其实是 **数组+链表+红黑树**的结合。当实例化一个 `HashMap`时，会初始化 `initialCapacity`和 `loadFactor`，在 `put`第一对映射关系时，系统会创建一个长度为 `initialCapacity`的 `Node`数组，这个长度在哈希表中被称为容量(`Capacity`)，在这个数组中可以存放元素的位置我们称之为"桶"(`bucket`)，每个 `bucket`都有自己的索引，系统可以根据索引快速的查找 `bucket`中的元素
* 每个 `bucket`中存储一个元素，即一个 `Node`对象，但每一个 `Node`对象可以带一个引用变量 `next`，用于指向下一个元素，因此，在一个桶中，就有可能生成一个 `Node`链。也可能是一个一个 `TreeNode`对象，每一个 `TreeNode`对象可以有两个叶子结点 `left`和 `right`，因此，在一个桶中，就有可能生成一个 `TreeNode`树。而新添加的元素作为链表的 `last`，或树的叶子结点。
* **那么HashMap什么时候进行扩容和树形化呢？** 当 `HashMap`中的元素个数超过 `&#x6570;&#x7EC4;&#x5927;&#x5C0F;(&#x6570;&#x7EC4;&#x603B;&#x5927;&#x5C0F;length,&#x4E0D;&#x662F;&#x6570;&#x7EC4;&#x4E2D;&#x4E2A;&#x6570;size)*loadFactor`时，就会进行数组扩容， `loadFactor`的默认值(DEFAULT_LOAD_FACTOR)为 `0.75`，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过 `16*0.75=12`（这个值就是代码中的t `hreshold`值，也叫做临界值）的时候，就把数组的大小扩展为 `2*16=32`，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 `HashMap`中元素的个数，那么预设元素的个数能够有效的提高 `HashMap`的性能。
* 当 `HashMap`中的其中一个链的对象个数如果达到了 `8`个，此时如果 `capacity`没有达到 `64`，那么 `HashMap`会先扩容解决，如果已经达到了 `64`，那么这个链会变成红黑树，结点类型由 `Node`变成 `TreeNode`类型。当然，如果当映射关系被移除后，下次 `resize`方法时判断树的结点个数低于 `6`个，也会把红黑树再转为链表。
* **关于映射关系的 `key` 是否可以修改？answer：不要修改** 映射关系存储到 `HashMap`中会存储 `key`的 `hash`值，这样就不用在每次查找时重新计算每一个 `Entry`或 `Node&#xFF08;TreeNode&#xFF09;`的 `hash`值了，因此如果已经 `put`到 `Map`中的映射关系，再修改 `key`的属性，而这个属性又参与 `hashcode`值的计算，那么会导致匹配不上。

### 6.7、LinkedHashMap的底层实现原理（了解）

* `LinkedHashMap`是 `HashMap`的子类
* 在 `HashMap`存储结构的基础上，使用了一对双向链表来记录添加元素的顺序
* 与 `LinkedHashSet`类似， `LinkedHashMap`可以维护 `Map` 的迭代顺序：迭代顺序与 `Key-Value` 对的插入顺序一致
* `HashMap`中的内部类： `Node`
![](https://img-blog.csdnimg.cn/img_convert/342cf58820c14e037baaadd31c600d80.png)
* `LinkedHashMap`中的内部类： `Entry`
![](https://img-blog.csdnimg.cn/img_convert/edbc291a09efb65428640308c90d7b8b.png)

```java

import org.junit.Test;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

public class MapTest {

    @Test
    public void test2(){
        Map map = new HashMap();
        map = new LinkedHashMap();
        map.put(123,"AA");
        map.put(345,"BB");
        map.put(12,"CC");

        System.out.println(map);
    }
}
```

### 6.8、Map中的常用方法1

```java
import org.junit.Test;

import java.util.*;

public class MapTest {

    @Test
    public void test4(){
        Map map = new HashMap();
        map.put("AA",123);
        map.put(45,123);
        map.put("BB",56);

        System.out.println(map.get(45));

        boolean isExist = map.containsKey("BB");
        System.out.println(isExist);

        isExist = map.containsValue(123);
        System.out.println(isExist);

        map.clear();

        System.out.println(map.isEmpty());
    }

    @Test
    public void test3(){
        Map map = new HashMap();

        map.put("AA",123);
        map.put(45,123);
        map.put("BB",56);

        map.put("AA",87);

        System.out.println(map);

        Map map1 = new HashMap();
        map1.put("CC",123);
        map1.put("DD",456);
        map.putAll(map1);

        System.out.println(map);

        Object value = map.remove("CC");
        System.out.println(value);
        System.out.println(map);

        map.clear();
        System.out.println(map.size());
        System.out.println(map);
    }
}
```

### 6.9、Map中的常用方法2

```java
import org.junit.Test;

import java.util.*;

public class MapTest {

    @Test
    public void test5(){
        Map map = new HashMap();
        map.put("AA",123);
        map.put(45,1234);
        map.put("BB",56);

        Set set = map.keySet();
        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
        System.out.println("*****************");

        Collection values = map.values();
        for(Object obj : values){
            System.out.println(obj);
        }
        System.out.println("***************");

        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
            Object obj = iterator1.next();

            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + "---->" + entry.getValue());

        }
        System.out.println("/");

        Set keySet = map.keySet();
        Iterator iterator2 = keySet.iterator();
        while(iterator2.hasNext()){
            Object key = iterator2.next();
            Object value = map.get(key);
            System.out.println(key + "=====" + value);
        }
    }
}
```

### 6.10、TreeMap两种添加方式的使用

* `TreeMap`存储 `Key-Value` 对时，需要根据 `key-value`对进行排序。 `TreeMap`可以保证所有的 `Key-Value` 对处于 **有序**状态。
* `TreeSet`底层使用 **红黑树**结构存储数据
* `TreeMap`的 `Key`的排序：
  - **自然排序**： `TreeMap`的所有的 `Key` 必须实现 `Comparable`接口，而且所有的 `Key`应该是同一个类的对象，否则将会抛出 `ClasssCastException`
  - **定制排序**：创建 `TreeMap`时，传入一个 `Comparator` 对象，该对象负责对 `TreeMap`中的所有 `key` 进行排序。此时不需要 `Map` 的 `Key`实现 `Comparable` 接口
* `TreeMap`判断 **两个 `key` 相等**的标准：两个 `key`通过 `compareTo()`方法或者 `compare()`方法返回 `0`。

> 1、User类

```java
public class User implements Comparable{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        System.out.println("User equals()....");
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    @Override
    public int compareTo(Object o) {
        if(o instanceof User){
            User user = (User)o;

            int compare = -this.name.compareTo(user.name);
            if(compare != 0){
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        }else{
            throw new RuntimeException("输入的类型不匹配");
        }

    }
}
```

> 2、测试类

```java
import org.junit.Test;

import java.util.*;

public class TreeMapTest {

    @Test
    public void test(){
        TreeMap map = new TreeMap();
        User u1 = new User("Tom",23);
        User u2 = new User("Jerry",32);
        User u3 = new User("Jack",20);
        User u4 = new User("Rose",18);

        map.put(u1,98);
        map.put(u2,89);
        map.put(u3,76);
        map.put(u4,100);

        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
            Object obj = iterator1.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + "---->" + entry.getValue());

        }
    }

    @Test
    public void test2(){
        TreeMap map = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof User && o2 instanceof User){
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    return Integer.compare(u1.getAge(),u2.getAge());
                }
                throw new RuntimeException("输入的类型不匹配！");
            }
        });
        User u1 = new User("Tom",23);
        User u2 = new User("Jerry",32);
        User u3 = new User("Jack",20);
        User u4 = new User("Rose",18);

        map.put(u1,98);
        map.put(u2,89);
        map.put(u3,76);
        map.put(u4,100);

        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
            Object obj = iterator1.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + "---->" + entry.getValue());

        }
    }
}
```

### 6.12、Hashtable

* `Hashtable`是个古老的 `Map` 实现类，JDK1.0就提供了。不同于 `HashMap`， `Hashtable`是线程安全的。
* `Hashtable`实现原理和 `HashMap`相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。
* 与 `HashMap`不同， **`Hashtable` 不允许使用 `null` 作为 `key` 和 `value`**
* 与 `HashMap`一样， `Hashtable`也不能保证其中 `Key-Value` 对的顺序
* `Hashtable`判断两个 `key`相等、两个 `valu`e相等的标准，与 `HashMap`一致。

### 6.13、Properties处理属性文件

* `Properties` 类是 `Hashtable`的子类，该对象用于处理属性文件
* 由于属性文件里的 `key&#x3001;value`都是字符串类型，所以**`Properties` 里的 `key`和 `value`都是字符串类型**
* 存取数据时，建议使用 `setProperty(String key,Stringvalue)`方法和 `getProperty(String key)`方法

> 1、新建jdbc.properties文件

![](https://img-blog.csdnimg.cn/img_convert/4800b141e7d9bb3c43211acd9f24b4e5.png)
![](https://img-blog.csdnimg.cn/img_convert/e169a742c42b31bbd860df5cfd975025.png)
![](https://img-blog.csdnimg.cn/img_convert/853471dde7dc490ea21e65190a65cb51.png)

> 2、编写源代码

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class PropertiesTest {

    public static void main(String[] args){

        FileInputStream fis = null;
        try {
            Properties pros = new Properties();
            fis = new FileInputStream("jdbc.properties");
            pros.load(fis);

            String name = pros.getProperty("name");
            String password = pros.getProperty("password");

            System.out.println("name = " + name + ",password = " + password);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

> 如果jdbc.properties文件中写入为中文；
防止jdbc.properties出现中文乱码，可根据如下解决：

![](https://img-blog.csdnimg.cn/img_convert/d6e32450043ebfc6998bdbd1e1e6d815.png)

> 新建jdbc.properties

![](https://img-blog.csdnimg.cn/img_convert/68dbda5f6415e90fd9033604e8403f7c.png)

## 07、Collections工具类

* 操作数组的工具类： `Arrays`
* `Collections` 是一个操作 `Set&#x3001;List`和 `Map` 等集合的工具类
* `Collections`中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法
* 排序操作：（均为 `static`方法）
  - `reverse(List)`：反转List 中元素的顺序
  - `shuffle(List)`：对List集合元素进行随机排序
  - `sort(List)`：根据元素的自然顺序对指定List 集合元素按升序排序
  - `sort(List&#xFF0C;Comparator)`：根据指定的Comparator 产生的顺序对List 集合元素进行排序
  - `swap(List&#xFF0C;int&#xFF0C;int)`：将指定list 集合中的i处元素和j 处元素进行交换

### 7.1、Collections工具类常用方法的测试

```java
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class CollectionTest {

    @Test
    public void test(){
        List list = new ArrayList();
        list.add(123);
        list.add(43);
        list.add(765);
        list.add(765);
        list.add(765);
        list.add(-97);
        list.add(0);

        System.out.println(list);

        int frequency = Collections.frequency(list, 123);

        System.out.println(list);
        System.out.println(frequency);
    }

    @Test
    public void test2(){
        List list = new ArrayList();
        list.add(123);
        list.add(43);
        list.add(765);
        list.add(-97);
        list.add(0);

        List dest = Arrays.asList(new Object[list.size()]);
        System.out.println(dest.size());
        Collections.copy(dest,list);

        System.out.println(dest);

        List list1 = Collections.synchronizedList(list);
    }
}
```

### 7.2、补充：Enumeration(了解！！！)

* `Enumeration` 接口是 `Iterator`迭代器的"古老版本"

![](https://img-blog.csdnimg.cn/img_convert/0941872358abded0001ec9579776852f.png)

```java
Enumeration stringEnum = new StringTokenizer("a-b*c-d-e-g", "-");
    while(stringEnum.hasMoreElements()){
        Object obj= stringEnum.nextElement();System.out.println(obj);
    }
```


## 01、File类的使用

### 1.1、File类的实例化

* `java.io.File`类：文件和文件目录路径的抽象表示形式，与平台无关
* File 能新建、删除、重命名文件和目录，但File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。
* 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。
* File对象可以作为参数传递给流的构造器

```java
import org.junit.Test;
import java.io.File;

public class FileTest {

    @Test
    public void test(){

        File file1 = new File("hello.txt");
        File file2 = new File("F:\\java\\Work2\\JavaSenior\\day08\\num.txt");

        System.out.println(file1);
        System.out.println(file2);

        File file3 = new File("D:\\workspace_idea1","JavaSenior");
        System.out.println(file3);

        File file4 = new File(file3,"hi.txt");
        System.out.println(file4);
    }

}
```

### 1.2、File类的常用方法1

```java
import org.junit.Test;

import java.io.File;
import java.util.Date;

public class FileTest {

    @Test
    public void test2(){
        File file = new File("Hello.txt");
        File file2 = new File("F:\\java\\Work2\\JavaSenior\\day08\\num.txt");

        System.out.println(file.getAbsolutePath());
        System.out.println(file.getPath());
        System.out.println(file.getName());
        System.out.println(file.getParent());
        System.out.println(file.length());
        System.out.println(new Date(file.lastModified()));

        System.out.println();

        System.out.println(file2.getAbsolutePath());
        System.out.println(file2.getPath());
        System.out.println(file2.getName());
        System.out.println(file2.getParent());
        System.out.println(file2.length());
        System.out.println(file2.lastModified());
    }

    @Test
    public void test3(){

        File file = new File("F:\\java\\Work2\\JavaSenior");

        String[] list = file.list();
        for(String s : list){
            System.out.println(s);
        }

        System.out.println();

        File[] files = file.listFiles();
        for(File f : files){
            System.out.println(f);
        }
    }

    @Test
    public void test4(){
        File file1 = new File("hello.txt");
        File file2 = new File("D:\\book\\num.txt");

        boolean renameTo = file2.renameTo(file1);
        System.out.println(renameTo);
    }
}
```

### 1.3、File类的常用方法2

![](https://img-blog.csdnimg.cn/img_convert/e1cfd3ce0032867ebcb16dbcb5c06743.png)

```java
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.util.Date;

public class FileTest {

    @Test
    public void test5(){
        File file1 = new File("hello.txt");
        file1 = new File("hello1.txt");

        System.out.println(file1.isDirectory());
        System.out.println(file1.isFile());
        System.out.println(file1.exists());
        System.out.println(file1.canRead());
        System.out.println(file1.canWrite());
        System.out.println(file1.isHidden());

        System.out.println();

        File file2 = new File("D:\\book");
        file2 = new File("D:\\book1");
        System.out.println(file2.isDirectory());
        System.out.println(file2.isFile());
        System.out.println(file2.exists());
        System.out.println(file2.canRead());
        System.out.println(file2.canWrite());
        System.out.println(file2.isHidden());
    }

    @Test
    public void test6() throws IOException {
        File file1 = new File("hi.txt");
        if(!file1.exists()){

            file1.createNewFile();
            System.out.println("创建成功");
        }else{
            file1.delete();
            System.out.println("删除成功");
        }
    }

    @Test
    public void test7(){

        File file1 = new File("d:\\io\\io1\\io3");

        boolean mkdir = file1.mkdir();
        if(mkdir){
            System.out.println("创建成功1");
        }

        File file2 = new File("d:\\io\\io1\\io4");

        boolean mkdir1 = file2.mkdirs();
        if(mkdir1){
            System.out.println("创建成功2");
        }

        File file3 = new File("D:\\io\\io1\\io4");
        file3 = new File("D:\\io\\io1");
        System.out.println(file3.delete());
    }
}
```

### 1.4、课后练习

![](https://img-blog.csdnimg.cn/img_convert/2dea5f971514e90f57600a5898d5b62d.png)

> 1、FileTest类

```java
import org.junit.Test;

import java.io.File;
import java.io.IOException;

public class FileTest {
    @Test
    public void test() throws IOException {
        File file = new File("D:\\io\\io1\\hello.txt");

        File destFile = new File(file.getParent(),"haha.txt");
        boolean newFile = destFile.createNewFile();
        if(newFile){
            System.out.println("创建成功！");
        }
    }
}
```

> 2、FindJPGFileTest类

```java
import org.junit.Test;

import java.io.File;
import java.io.FilenameFilter;

public class FindJPGFileTest {
    @Test
    public void test(){
        File srcFile = new File("d:\\code");

        String[] fileNames = srcFile.list();
        for(String fileName : fileNames){
            if(fileName.endsWith(".jpg")){
                System.out.println(fileName);
            }
        }
    }

    @Test
    public void test2(){
        File srcFile = new File("d:\\code");

        File[] listFiles = srcFile.listFiles();
        for(File file : listFiles){
            if(file.getName().endsWith(".jpg")){
                System.out.println(file.getAbsolutePath());
            }
        }
    }

    @Test
    public void test3(){
        File srcFile = new File("d:\\code");

        File[] subFiles = srcFile.listFiles(new FilenameFilter() {

            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".jpg");
            }
        });

        for(File file : subFiles){
            System.out.println(file.getAbsolutePath());
        }
    }
}
```

> 3、ListFilesTest类

```java
import java.io.File;

public class ListFilesTest {
    public static void main(String[] args) {

        File dir = new File("E:\\teach\\01_javaSE\\_尚硅谷Java编程语言\\3_软件");

        printSubFile(dir);
    }

    public static void printSubFile(File dir) {

        File[] subfiles = dir.listFiles();

        for (File f : subfiles) {
            if (f.isDirectory()) {
                printSubFile(f);
            } else {
                System.out.println(f.getAbsolutePath());
            }

        }
    }

    public void listSubFiles(File file) {
        if (file.isDirectory()) {
            String[] all = file.list();
            for (String s : all) {
                System.out.println(s);
            }
        } else {
            System.out.println(file + "是文件！");
        }
    }

    public void listAllSubFiles(File file) {
        if (file.isFile()) {
            System.out.println(file);
        } else {
            File[] all = file.listFiles();

            for (File f : all) {
                listAllSubFiles(f);
            }
        }
    }

    public long getDirectorySize(File file) {

        long size = 0;
        if (file.isFile()) {
            size += file.length();
        } else {
            File[] all = file.listFiles();

            for (File f : all) {
                size += getDirectorySize(f);
            }
        }
        return size;
    }

    public void deleteDirectory(File file) {

        if (file.isDirectory()) {
            File[] all = file.listFiles();

            for (File f : all) {
                deleteDirectory(f);
            }
        }

        file.delete();
    }
}
```

## 02、IO流原理及流的分类

### 2.1、IO流原理

* I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。
* Java程序中，对于数据的输入/输出操作以"流(stream)"的方式进行。
* java.io包下提供了各种"流"类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。
* 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。
* 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。

![](https://img-blog.csdnimg.cn/img_convert/74982d54ff7df37618ef186ec7dad049.png)

### 2.2、流的分类

* 按操作 **数据单位**不同分为：字节流(8 bit)，字符流(16 bit)
* 按数据流的 **流向**不同分为：输入流，输出流
* 按流的 **角色**的不同分为：节点流，处理流

抽象基类字节流字符流输入流InputStreamReader输出流OutputStreamWriter

1. Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。
2. 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。

![](https://img-blog.csdnimg.cn/img_convert/23f558de081b9a9a2a5da93fdc1989df.png)

### 2.3、IO 流体系

![](https://img-blog.csdnimg.cn/img_convert/2cece5577c55fc427b9942a42e577fe4.png)

## 04、节点流(或文件流)

### 4.1、FileReader读入数据的基本操作

> 1、读取文件【四个步骤】

1. 建立一个流对象，将已存在的一个文件加载进流。

```java
FileReaderfr= new FileReader(new File("Test.txt"));
```
2. 创建一个临时存放数据的数组。

```java
char[] ch= new char[1024];
```
3. 调用流对象的读取方法将流中的数据读入到数组中。

```java
	fr.read(ch);
```
4. 关闭资源。

```java
	fr.close();
```

```java
import org.junit.Test;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class FileReaderWriterTest {
    public static void main(String[] args) {
        File file = new File("hello.txt");
        System.out.println(file.getAbsolutePath());

        File file1 = new File("day09\\hello.txt");
        System.out.println(file1.getAbsolutePath());
    }

    @Test
    public void test(){
        FileReader fr = null;
        try {

            File file = new File("hello.txt");

            fr = new FileReader(file);

            int data;
            while((data = fr.read()) != -1){
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {

            if(fr != null){
                try {
                    fr.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }
}
```

### 4.2、FileReader中使用read(char[] cbuf)读入数据

```java
import org.junit.Test;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class FileReaderWriterTest {

    @Test
    public void test2(){
        FileReader fr = null;
        try {

            File file = new File("hello.txt");

            fr = new FileReader(file);

            char[] cbuf = new char[5];
            int len;
            fr.read(cbuf);
            while((len = fr.read(cbuf)) != -1){

                String str = new String(cbuf,0,len);
                System.out.print(str);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(fr != null){

                try {
                    fr.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }

    }

}
```

### 4.3、FileWriter写出数据的操作

> 1、写入文件

1. 创建流对象，建立数据存放文件

```java
    FileWriterfw= new FileWriter(new File("Test.txt"));
```
2. 调用流对象的写入方法，将数据写入流

```java
  fw.write("atguigu-songhongkang");
```
3. 关闭流资源，并将流中的数据清空到文件中。

```java
    fw.close();
```

```java
import org.junit.Test;
import java.io.*;

public class FileReaderWriterTest {

    @Test
    public void test3(){
        FileWriter fw = null;
        try {

            File file = new File("hello1.txt");

            fw = new FileWriter(file,false);

            fw.write("I have a dream!\n");
            fw.write("you need to have a dream!");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            if(fw != null){

                try {
                    fw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

### 4.4、使用FileReader和FileWriter实现文本文件的复制

```java
import org.junit.Test;
import java.io.*;

public class FileReaderWriterTest {

    @Test
    public void test4() {
        FileReader fr = null;
        FileWriter fw = null;
        try {

            File srcFile = new File("hello1.txt");
            File srcFile2 = new File("hello2..txt");

            fr = new FileReader(srcFile);
            fw = new FileWriter(srcFile2);

            char[] cbuf = new char[5];
            int len;
            while((len = fr.read(cbuf)) != -1){

                fw.write(cbuf,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            try {
                if(fw != null)
                    fw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

            try {
                if(fr != null)
                    fr.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 4.5、使用FileInputStream不能读取文本文件的测试

```java
import org.junit.Test;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class FileIOPutTest {

    @Test
    public void testFileInputStream(){
        FileInputStream fis = null;
        try {

            File file = new File("hello.txt");

            fis = new FileInputStream(file);

            byte[] buffer = new byte[5];
            int len;
            while((len = fis.read(buffer)) != -1){
                String str = new String(buffer,0,len);
                System.out.print(str);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(fis != null) {

                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

### 4.6、使用FileInputStream和FileOutputStream读写非文本文件

```java
import org.junit.Test;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileIOPutTest {

    @Test
    public void testFileInputOutputStream()  {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {

            File srcFile = new File("爱情与友情.jpg");
            File destFile = new File("爱情与友情2.jpg");

            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);

            byte[] buffer = new byte[5];
            int len;

            while((len = fis.read(buffer)) != -1){
                fos.write(buffer,0,len);
            }
            System.out.println("复制成功");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(fos != null){

                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }

    }
}
```

### 4.7、使用FileInputStream和FileOutputStream复制文件的方法测试

```java
import org.junit.Test;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileIOPutTest {

    public void copyFile(String srcPath,String destPath){
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {

            File srcFile = new File(srcPath);
            File destFile = new File(destPath);

            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);

            byte[] buffer = new byte[1024];
            int len;
            while((len = fis.read(buffer)) != -1){
                fos.write(buffer,0,len);
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(fos != null){

                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }
    }

    @Test
    public void testCopyFile(){

        long start = System.currentTimeMillis();

        String srcPath = "hello.txt";
        String destPath = "hello3.txt";

        copyFile(srcPath,destPath);

        long end = System.currentTimeMillis();

        System.out.println("复制操作花费的时间为：" + (end - start));
    }
}
```

## 05、缓冲流

* 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。
![](https://img-blog.csdnimg.cn/img_convert/b127ea9bd12c05a70b88033ee70bf2f3.png)
* 缓冲流要"套接"在相应的节点流之上，根据数据操作单位可以把缓冲流分为：
  - BufferedInputStream和BufferedOutputStream
  - BufferedReader和BufferedWriter
* 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区
* 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。
* 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流
* 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流
* flush()方法的使用：手动将buffer中内容写入文件
* 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。

![](https://img-blog.csdnimg.cn/img_convert/7ce79819b9685ffc2bae685bec83b0f1.png)

### 5.1、缓冲流(字节型)实现非文本文件的复制

```java
import org.junit.Test;

import java.io.*;

public class BufferedTest {

    @Test
    public void BufferedStreamTest(){
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;

        try {

            File srcFile = new File("爱情与友情.jpg");
            File destFile = new File("爱情与友情3.jpg");

            FileInputStream fis = new FileInputStream((srcFile));
            FileOutputStream fos = new FileOutputStream(destFile);

            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);

            byte[] buffer = new byte[10];
            int len;
            while((len = bis.read(buffer)) != -1){
                bos.write(buffer,0,len);

            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            if(bos != null){
                try {
                    bos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
            if(bis != null){
                try {
                    bis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }
}
```

### 5.2、缓冲流与节点流读写速度对比

```java
import org.junit.Test;
import java.io.*;

public class BufferedTest {

    public void copyFileWithBuffered(String srcPath,String destPath){
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;

        try {

            File srcFile = new File(srcPath);
            File destFile = new File(destPath);

            FileInputStream fis = new FileInputStream((srcFile));
            FileOutputStream fos = new FileOutputStream(destFile);

            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);

            byte[] buffer = new byte[1024];
            int len;
            while((len = bis.read(buffer)) != -1){
                bos.write(buffer,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            if(bos != null){
                try {
                    bos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
            if(bis != null){
                try {
                    bis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }

        }
    }

    @Test
    public void testCopyFileWithBuffered(){
        long start = System.currentTimeMillis();

        String srcPath = "C:\\Users\\29433\\Desktop\\book.flv";
        String destPath = "C:\\Users\\29433\\Desktop\\book1.flv";

        copyFileWithBuffered(srcPath,destPath);

        long end = System.currentTimeMillis();

        System.out.println("复制操作花费的时间为：" + (end - start));
    }

}
```

![](https://img-blog.csdnimg.cn/img_convert/a6629278090d40d2322f85459e710eee.png)

### 5.3、缓冲流(字符型)实现文本文件的复制

```java
import org.junit.Test;
import java.io.*;

public class BufferedTest {

    @Test
    public void test4(){
        BufferedReader br = null;
        BufferedWriter bw = null;
        try {

            br = new BufferedReader(new FileReader(new File("dbcp.txt")));
            bw = new BufferedWriter(new FileWriter(new File("dbcp1.txt")));

            String data;
            while((data = br.readLine()) != null){

                bw.write(data);
                bw.newLine();
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            if(bw != null){

                try {
                    bw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(br != null){
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

![](https://img-blog.csdnimg.cn/img_convert/3c19bb7c87f1659a1aab43ea29cd1673.png)

### 5.4、缓冲流课后练习

![](https://img-blog.csdnimg.cn/img_convert/90531fa8b1e38303434349792a7eeaac.png)

> 1、练习2

```java
package git;

import org.junit.Test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class PicTest {

    @Test
    public void test() {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fis = new FileInputStream("爱情与友情.jpg");
            fos = new FileOutputStream("爱情与友情secret.jpg");

            byte[] buffer = new byte[20];
            int len;
            while ((len = fis.read(buffer)) != -1) {

                for (int i = 0; i < len; i++) {
                    buffer[i] = (byte) (buffer[i] ^ 5);
                }

                fos.write(buffer, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }

    @Test
    public void test2() {

        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fis = new FileInputStream("爱情与友情secret.jpg");
            fos = new FileOutputStream("爱情与友情4.jpg");

            byte[] buffer = new byte[20];
            int len;
            while ((len = fis.read(buffer)) != -1) {

                for (int i = 0; i < len; i++) {
                    buffer[i] = (byte) (buffer[i] ^ 5);
                }

                fos.write(buffer, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}
```

> 2、练习3

```java
import org.junit.Test;

import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class WordCount {

    @Test
    public void testWordCount() {
        FileReader fr = null;
        BufferedWriter bw = null;
        try {

            Map<Character, Integer> map = new HashMap<Character, Integer>();

            fr = new FileReader("dbcp.txt");
            int c = 0;
            while ((c = fr.read()) != -1) {

                char ch = (char) c;

                if (map.get(ch) == null) {
                    map.put(ch, 1);
                } else {
                    map.put(ch, map.get(ch) + 1);
                }
            }

            bw = new BufferedWriter(new FileWriter("wordcount.txt"));

            Set<Map.Entry<Character, Integer>> entrySet = map.entrySet();
            for (Map.Entry<Character, Integer> entry : entrySet) {
                switch (entry.getKey()) {
                    case ' ':
                        bw.write("空格=" + entry.getValue());
                        break;
                    case '\t'://\t表示tab 键字符
                        bw.write("tab键=" + entry.getValue());
                        break;
                    case '\r'://
                        bw.write("回车=" + entry.getValue());
                        break;
                    case '\n'://
                        bw.write("换行=" + entry.getValue());
                        break;
                    default:
                        bw.write(entry.getKey() + "=" + entry.getValue());
                        break;
                }
                bw.newLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {

            if (fr != null) {
                try {
                    fr.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
            if (bw != null) {
                try {
                    bw.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }
    }
}
```

## 06、转换流

### 6.1、转换流概述与InputStreamReader的使用

* 转换流提供了在字节流和字符流之间的转换
* Java API提供了两个转换流：
  - `InputStreamReader`：将InputStream转换为Reader
    + 实现将字节的输入流按指定字符集转换为字符的输入流。
    + 需要和 `InputStream`"套接"。
    + 构造器
      * `public InputStreamReader(InputStreamin)`
      * `public InputSreamReader(InputStreamin,StringcharsetName)`
      * `&#x5982;&#xFF1A;Reader isr= new InputStreamReader(System.in,&#x201D;gbk&#x201D;);`
  - `OutputStreamWriter`：将Writer转换为OutputStream
    + 实现将字符的输出流按指定字符集转换为字节的输出流。
    + 需要和 `OutputStream`"套接"。
    + 构造器
      * `public OutputStreamWriter(OutputStreamout)`
      * `public OutputSreamWriter(OutputStreamout,StringcharsetName)`
* 字节流中的数据都是字符时，转成字符流操作更高效。
* 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。

![](https://img-blog.csdnimg.cn/img_convert/4dfa85f71b54ed2d8e3a43371933b7fb.png)

```java
import org.junit.Test;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class InputStreamReaderTest {

    @Test
    public void test() throws IOException {

        FileInputStream fis = new FileInputStream("dbcp.txt");

        InputStreamReader isr = new InputStreamReader(fis,"UTF-8");

        char[] cbuf = new char[20];
        int len;
        while((len = isr.read(cbuf)) != -1){
            String str = new String(cbuf,0,len);
            System.out.print(str);
        }

        isr.close();
    }

}
```

### 6.2、转换流实现文件的读入和写出

```java
import org.junit.Test;

import java.io.*;

public class InputStreamReaderTest {

    @Test
    public void test2() throws IOException {

        File file1 = new File("dbcp.txt");
        File file2 = new File("dbcp_gbk.txt");

        FileInputStream fis = new FileInputStream(file1);
        FileOutputStream fos = new FileOutputStream(file2);

        InputStreamReader isr = new InputStreamReader(fis,"utf-8");
        OutputStreamWriter osw = new OutputStreamWriter(fos,"gbk");

        char[] cbuf = new char[20];
        int len;
        while((len = isr.read(cbuf)) != -1){
            osw.write(cbuf,0,len);
        }

        isr.close();
        osw.close();
    }
}
```

### 6.3、多种字符编码集的说明

> 1、编码表的由来

计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。

> 2、常见的编码表
> 说明：

* Unicode不完美，这里就有三个问题，
一个是，我们已经知道，英文字母只用一个字节表示就够了，
第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？
第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。
* 面向传输的众多UTF（UCS Transfer Format）标准出现了，顾名思义，**UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。**这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。
* Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。

![](https://img-blog.csdnimg.cn/img_convert/b886d2a72df648a1e6bd5ffcf2db9dc3.png)
![](https://img-blog.csdnimg.cn/img_convert/35ad9abbbf83b4ea957ce978bac16873.png)

## 07、标准输入、输出流

* System.in和System.out分别代表了系统标准的输入和输出设备
* 默认输入设备是：键盘，输出设备是：显示器
* System.in的类型是InputStream
* System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类
* 重定向：通过System类的setIn，setOut方法对默认设备进行改变。
  - public static void setIn(InputStreamin)
  - public static void setOut(PrintStreamout)

```java
import org.junit.Test;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class OtherStreamTest {

    @Test
    public void test(){
        BufferedReader br = null;
        try {
            InputStreamReader isr = new InputStreamReader(System.in);
            br = new BufferedReader(isr);

            while (true) {
                System.out.println("请输入字符串：");
                String data = br.readLine();
                if ("e".equalsIgnoreCase(data) || "exit".equalsIgnoreCase(data)) {
                    System.out.println("程序结束");
                    break;
                }

                String upperCase = data.toUpperCase();
                System.out.println(upperCase);

            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (br != null) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }
    }
}
```

## 08、打印流

* 实现将基本数据类型的数据格式转化为字符串输出
* 打印流：PrintStream和PrintWriter
  - 提供了一系列重载的print()和println()方法，用于多种数据类型的输出
  - PrintStream和PrintWriter的输出不会抛出IOException异常
  - PrintStream和PrintWriter有自动flush功能
  - PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter 类。
  - System.out返回的是PrintStream的实例

```java
import org.junit.Test;
import java.io.*;

public class OtherStreamTest {

    @Test
    public void test2(){
        PrintStream ps = null;
        try {
            FileOutputStream fos = new FileOutputStream(new File("D:\\IO\\text.txt"));

            ps = new PrintStream(fos, true);
            if (ps != null) {
                System.setOut(ps);
            }

            for (int i = 0; i  255; i++) {
                System.out.print((char) i);
                if (i % 50 == 0) {
                    System.out.println();
                }
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (ps != null) {
                ps.close();
            }
        }
    }
}
```

## 09、数据流

* 为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。
* 数据流有两个类：(用于读取和写出基本数据类型、String类的数据）
  - DataInputStream和DataOutputStream
  - 分别"套接"在InputStream和OutputStream子类的流上
* DataInputStream中的方法

```java
boolean readBoolean()	byte readByte()
char readChar()	float readFloat()
double readDouble()	short readShort()
long readLong()	int readInt()
String readUTF()	void readFully(byte[s] b)
```
* DataOutputStream中的方法
  - 将上述的方法的read改为相应的write即可。

```java
import org.junit.Test;
import java.io.*;

public class OtherStreamTest {

    @Test
    public void test3() throws IOException {

        DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.txt"));

        dos.writeUTF("刘刚");
        dos.flush();
        dos.writeInt(23);
        dos.flush();
        dos.writeBoolean(true);
        dos.flush();

        dos.close();
    }

    @Test
    public void test4() throws IOException {

        DataInputStream dis = new DataInputStream(new FileInputStream("data.txt"));

        String name = dis.readUTF();
        int age = dis.readInt();
        boolean isMale = dis.readBoolean();

        System.out.println("name = " + name);
        System.out.println("age = " + age);
        System.out.println("isMale = " + isMale);

        dis.close();

    }
}
```

## 10、对象流

### 10.1、对象序列化机制的理解

* `ObjectInputStream`和 `OjbectOutputSteam`
* 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。
* 序列化：用 `ObjectOutputStream`类保存基本类型数据或对象的机制
* 反序列化：用 `ObjectInputStream`类读取基本类型数据或对象的机制
* `ObjectOutputStream`和 `ObjectInputStream`不能序列化 `static`和 `transient`修饰的成员变量
* 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象
* 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原
* 序列化是RMI（Remote Method Invoke –远程方法调用）过程的参数和返回值都必须实现的机制，而RMI 是JavaEE的基础。因此序列化机制是JavaEE平台的基础
* 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出 `NotSerializableException`异常
  - `Serializable`
  - `Externalizable`

### 10.2、对象流序列化与反序列化字符串操作

```java
import org.junit.Test;

import java.io.*;

public class ObjectTest {

    @Test
    public void test(){
        ObjectOutputStream oos = null;
        try {

            oos = new ObjectOutputStream(new FileOutputStream("object.dat"));

            oos.writeObject(new String("秦始皇陵欢迎你"));

            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(oos != null){

                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    @Test
    public void test2(){
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream("object.dat"));

            Object obj = ois.readObject();
            String str = (String) obj;

            System.out.println(str);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if(ois != null){
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

}
```

### 10.3、自定义类实现序列化与反序列化操作

* 若某个类实现了 `Serializable`接口，该类的对象就是可序列化的：
  - 创建一个 `ObjectOutputStream`
  - 调用 `ObjectOutputStream`对象的 `writeObject(&#x5BF9;&#x8C61;)` 方法输出可序列化对象
  - 注意写出一次，操作flush()一次
* 反序列化
  - 创建一个 `ObjectInputStream`对象调用 `readObject()` 方法读取流中的对象
* 强调：如果某个类的属性不是基本数据类型或String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化

> 1、Person类

```java
import java.io.Serializable;

public class Person implements Serializable {
    public static final long serialVersionUID = 475463534532L;

    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

> 2、测试类

```java
import org.junit.Test;

import java.io.*;

public class ObjectTest {

    @Test
    public void test(){
        ObjectOutputStream oos = null;
        try {

            oos = new ObjectOutputStream(new FileOutputStream("object.dat"));

            oos.writeObject(new String("秦始皇陵欢迎你"));

            oos.flush();

            oos.writeObject(new Person("李时珍",65));
            oos.flush();

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(oos != null){

                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    @Test
    public void test2(){
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream("object.dat"));

            Object obj = ois.readObject();
            String str = (String) obj;

            Person p = (Person) ois.readObject();

            System.out.println(str);
            System.out.println(p);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if(ois != null){
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

}
```

### 10.4、serialVersionUID的理解

* 凡是实现 `Serializable`接口的类都有一个表示序列化版本标识符的静态变量：
  - `private static final long serialVersionUID`;
  - `serialVersionUID`用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。
  - 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改， `serialVersionUID`可能发生变化。故建议，显式声明。
* 简单来说，Java的序列化机制是通过在运行时判断类的 `serialVersionUID`来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的 `serialVersionUID`与本地相应实体类的 `serialVersionUID`进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)

> 1、Person类

```java
import java.io.Serializable;

public class Person implements Serializable {
    public static final long serialVersionUID = 475463534532L;

    private String name;
    private int age;
    private int id;

    public Person() {
    }

    public Person(String name, int age, int id) {
        this.name = name;
        this.age = age;
        this.id = id;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

> 2、测试类

```java
import org.junit.Test;

import java.io.*;

public class ObjectTest {

    @Test
    public void test(){
        ObjectOutputStream oos = null;
        try {

            oos = new ObjectOutputStream(new FileOutputStream("object.dat"));

            oos.writeObject(new String("秦始皇陵欢迎你"));

            oos.flush();

            oos.writeObject(new Person("李时珍",65,0));
            oos.flush();

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(oos != null){

                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    @Test
    public void test2(){
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream("object.dat"));

            Object obj = ois.readObject();
            String str = (String) obj;

            Person p = (Person) ois.readObject();

            System.out.println(str);
            System.out.println(p);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if(ois != null){
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

}
```

### 10.7、自定义类可序列化的其它要求

> 1、Person类

```java
import java.io.Serializable;

public class Person implements Serializable{

    public static final long serialVersionUID = 475463534532L;

    private String name;
    private int age;
    private int id;
    private Account acct;

    public Person(String name, int age, int id) {
        this.name = name;
        this.age = age;
        this.id = id;
    }

    public Person(String name, int age, int id, Account acct) {
        this.name = name;
        this.age = age;
        this.id = id;
        this.acct = acct;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", id=" + id +
                ", acct=" + acct +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(String name, int age) {

        this.name = name;
        this.age = age;
    }

    public Person() {

    }
}

class Account implements Serializable{
    public static final long serialVersionUID = 4754534532L;
    private double balance;

    @Override
    public String toString() {
        return "Account{" +
                "balance=" + balance +
                '}';
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public Account(double balance) {

        this.balance = balance;
    }
}
```

> 2、测试类

```java
import org.junit.Test;

import java.io.*;

public class ObjectTest {

    @Test
    public void test(){
        ObjectOutputStream oos = null;
        try {

            oos = new ObjectOutputStream(new FileOutputStream("object.dat"));

            oos.writeObject(new String("秦始皇陵欢迎你"));

            oos.flush();

            oos.writeObject(new Person("李时珍",65));
            oos.flush();

            oos.writeObject(new Person("张学良",23,1001,new Account(5000)));
            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(oos != null){

                try {
                    oos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    @Test
    public void test2(){
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream("object.dat"));

            Object obj = ois.readObject();
            String str = (String) obj;

            Person p = (Person) ois.readObject();

            System.out.println(str);
            System.out.println(p);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if(ois != null){
                try {
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

}
```

## 11、随机存取文件流

* `RandomAccessFile` 声明在 `java.io`包下，但直接继承于 `java.lang.Object`类。并且它实现了 `DataInput&#x3001;DataOutput`这两个接口，也就意味着这个类 **既可以读也可以写**。
* `RandomAccessFile` 类支持"随机访问" 的方式，程序可以直接跳到文件的任意地方来读、写文件
  - 支持只访问文件的部分内容
  - 可以向已存在的文件后追加内容
* `RandomAccessFile` 对象包含一个记录指针，用以标示当前读写处的位置。 `RandomAccessFile`类对象可以自由移动记录指针：
  - `long getFilePointer()`：获取文件记录指针的当前位置
  - `void seek(long pos)`：将文件记录指针定位到pos位置
* 构造器
  - `public RandomAccessFile(Filefile, Stringmode)`
  - `public RandomAccessFile(Stringname, Stringmode)`
* 创建RandomAccessFile类实例需要指定一个mode 参数，该参数指定RandomAccessFile的访问模式：
  - `r`: 以只读方式打开
  - `rw`：打开以便读取和写入
  - `rwd`:打开以便读取和写入；同步文件内容的更新
  - `rws`:打开以便读取和写入；同步文件内容和元数据的更新
* 如果模式为只读 `r`。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为 `rw`读写。如果文件不存在则会去创建文件，如果存在则不会创建。

### 11.1、RandomAccessFile实现数据的读写操作

```java
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;

public class RandomAccessFileTest {

    @Test
    public void test(){

        RandomAccessFile raf1 = null;
        RandomAccessFile raf2 = null;
        try {
            raf1 = new RandomAccessFile(new File("爱情与友情.jpg"),"r");
            raf2 = new RandomAccessFile(new File("爱情与友情1.jpg"),"rw");

            byte[] buffer = new byte[1024];
            int len;
            while((len = raf1.read(buffer)) != -1){
                raf2.write(buffer,0,len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(raf1 != null){
                try {
                    raf1.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
            if(raf2 != null){
                try {
                    raf2.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }

    @Test
    public void test2() throws IOException {

        RandomAccessFile raf1 = new RandomAccessFile("hello.txt","rw");

        raf1.write("xyz".getBytes());

        raf1.close();

    }

}
```

### 11.2、RandomAccessFile实现数据的插入操作

```java
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;

public class RandomAccessFileTest {

    @Test
    public void test3() throws IOException {
        RandomAccessFile raf1 = new RandomAccessFile("hello.txt","rw");

        raf1.seek(3);

        StringBuilder builder = new StringBuilder((int) new File("hello.txt").length());
        byte[] buffer = new byte[20];
        int len;
        while((len = raf1.read(buffer)) != -1){
            builder.append(new String(buffer,0,len)) ;
        }

        raf1.seek(3);
        raf1.write("xyz".getBytes());

        raf1.write(builder.toString().getBytes());

        raf1.close();

    }

}
```

## 12、NIO.2中Path、Paths、Files类的使用

* `Java NIO` (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。
* Java API中提供了两套NIO，一套是针对 **标准输入输出NIO**，另一套就是 **网络编程NIO**。

```java
|-----java.nio.channels.Channel
    |-----FileChannel:处理本地文件
    |-----SocketChannel：TCP网络编程的客户端的Channel
    |-----ServerSocketChannel:TCP网络编程的服务器端的Channel
    |-----DatagramChannel：UDP网络编程中发送端和接收端的Channel
12345
```
* 随着JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 `NIO.2`。因为NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。
* 早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。
* `NIO. 2`为了弥补这种不足，引入了 `Path`接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。
  - 在以前IO操作都是这样写的:

```java
import java.io.File;

File file = new File("index.html");
```
  - 但在Java7 中，我们可以这样写：

```java
import java.nio.file.Path;
import java.nio.file.Paths;
Path path = Paths.get("index.html");
```
* 同时，NIO.2在 `java.nio.file`包下还提供了 `Files&#x3001;Paths`工具类， `Files`包含了大量静态的工具方法来操作文件； `Paths`则包含了两个返回 `Path`的静态工厂方法。
* `Paths`类提供的静态 `get()`方法用来获取 `Path`对象：
  - `static Pathget(String first, String &#x2026; more)` : 用于将多个字符串串连成路径
  - `static Path get(URI uri)`: 返回指定uri对应的Path路径

> 1、Path接口

![](https://img-blog.csdnimg.cn/img_convert/6b9b053461f8e826c26a05b5165f0554.png)

> 2、Files 类

![](https://img-blog.csdnimg.cn/img_convert/136c25b4e21abb2636a8e2da960c62d1.png)
![](https://img-blog.csdnimg.cn/img_convert/8982f1154c6cb449ecf5695d8f1142cf.png)


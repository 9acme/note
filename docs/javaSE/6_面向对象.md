## 01、面向过程与面向对象

何谓“面向对象”的编程思想？
首先解释一下“思想”。
先问你个问题：你想做个怎样的人？
可能你会回答：我想做个好人，孝敬父母，尊重长辈，关爱亲朋…
你看，这就是思想。这是你做人的思想，或者说，是你做人的原则。做人有做人的原则，编程也有编程的原则。这些编程的原则呢，就是编程思想。

> 面向过程(POP) 与面向对象(OOP)

*   面向对象：Object Oriented Programming
*   面向过程：Procedure Oriented Programming

```java
/*
 * 一、学习面向对象内容的三条主线
 * 1.Java 类及类的成员：属性、方法、构造器、代码块、内部类
 * 2.面向对象的三大特征：封装、继承、多态性、(抽象性)
 * 3.其它关键字：this、super、static、final、abstract、interface、package、import 等
 *
 * 二、人把大象装进冰箱
 * 1.面向过程:强调的是功能行为，以函数为最小单位，考虑怎么做。
 *
 * ① 打开冰箱
 * ② 把大象装进冰箱
 * ③ 把冰箱门关住
 *
 * 2.面向对象:强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
 * 人{
 * 		打开(冰箱){
 * 			冰箱.开门();
 * 		}操作(大象){
 * 			大象.进入(冰箱);
 * 		}关闭(冰箱){
 * 			 冰箱.关门();
 * 		}
 * }
 *
 * 冰箱{
 * 		开门(){
 * 		}
 * 		关门(){
 * 		}
 * }
 *
 * 大象{
 * 		进入(冰箱){
 * 		}
 * }
 */
```

> 面向对象的思想概述

*   程序员从面向过程的执行者转化成了面向对象的指挥者
*   面向对象分析方法分析问题的思路和步骤：
    *   根据问题需要，选择问题所针对的现实世界中的实体。
    *   从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。
    *   把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。
    *   将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。

## 02、 类和对象

```java
/*
 * 三、面向对象的两个要素：
 * 类:对一类事物的描述，是抽象的、概念上的定义
 * 对象:是实际存在的该类事物的每个个体，因而也称为实	例(instance)。
 * 可以理解为：类= 抽象概念的人；对象= 实实在在的某个人
 * 面向对象程序设计的重点是类的设计；
 * 设计类，其实就是设计类的成员。
 */
```

### 2.1、Java 类及类的成员

现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java 代码世界是由诸多个不同功能的类构成的。

现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、… 那么，Java 中用类 class 来描述事物也是如此。常见的类的成员有：

*   属性：对应类中的成员变量
*   行为：对应类中的成员方法

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/e79fe23f155bb7d7a4fc1d9305df21d7.png)

### 2.2、类与对象的创建及使用

```java
/*
 * 一、设计类、其实就是设计类的成员
 * Field = 属性 = 成员变量 = 域、字段
 * Method = (成员)方法 = 函数
 *
 * 创建类 = 类的实例化 = 实例化类
 *
 * 二.类和对象的使用(面向对象思想落地的实现)
 * 1.创建类，设计类的成员
 * 2.创建类的对象
 * 3.通过“对象.属性”或“对象.方法”调用对象的结构
 * 三、如果创建类一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非 static 的)
 * 	  意味着:如果我们修改一个对象的属性 a，则不影响另外一个对象属性 a 的值。
 */
//测试类
public class PersonTest {
	public static void main(String[] args) {
		//2.创建 Person 类的对象
		//创建对象语法：类名对象名= new 类名();
		Person p1 = new Person();
		//Scanner scan = new Scanner(System.in);

		//调用类的结构：属性、方法
		//调用属性:“对象.属性”
		p1.name = "Tom";
		p1.age = 25;
		p1.isMale = true;
		System.out.println(p1.name);

		//调用方法:“对象.方法”
		p1.eat();
		p1.sleep();
		p1.talk("chinese");
		//**********************
		Person p2 = new Person();
		System.out.println(p2.name); //null
		System.out.println(p2.isMale);
		//**********************
		//将 p1 变量保存的对象地址值赋给 p3,导致 p1 和 p3 指向了堆空间中的一个对象实体。
		Person p3 = p1;
		System.out.println(p3.name);

		p3.age = 10;
		System.out.println(p1.age); //10
	}
}
/*
 * 类的语法格式：
 * 修饰符 class 类名{
 * 		属性声明;
 * 		方法声明;
 * }
 * 说明：修饰符 public：类可以被任意访问类的正文要用{  }括起来
 */
//1.创建类，设计类的成员
class Person{

	//属性:对应类中的成员变量
	String name;
	int age;
	boolean isMale;

	//方法:对应类中的成员方法
	public void eat(){
		System.out.println("吃饭");
	}

	public void sleep(){
		System.out.println("睡觉");
	}

	public void talk(String language){
		System.out.println("人可以说话，使用的是：" + language);
	}
}
```

### 2.3、对象的创建和使用：内存解析

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/fd7a664a69d935533b176a0397576172.png)

*   堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。
*   通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。
*   方法区（MethodArea），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

> 1、案例 1

```java
Person p1= newPerson();
p1.name = "Tom";
p1.isMale = true;
Person p2 = new Person();
sysout(p2.name);//null
Person p3 = p1;
p3.age = 10;
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/e10710c43389ff33e23d546de2ee864a.png)

> 2、案例 2

```java
Person p1= newPerson();
p1.name = "胡利民";
p1.age = 23;
Person p2 = new Person();
p2.age = 10;
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/d18ba9800da19fa278004bee59637fa4.png)

## 03、类的成员之一：属性

```java
/*
 * 类中属性的使用
 *
 * 属性(成员变量)	vs	局部变量
 * 1.相同点:
 * 		1.1 定义变量的格式:数据类型 变量名 = 变量值
 * 		1.2 先声明，后使用
 * 		1.3 变量都有其对应的作用域
 *
 * 2.不同点:
 * 		2.1 在类中声明的位置不同
 * 		属性:直接定义在类的一对{}内
 * 		局部变量:声明在方法内、方法形参、构造器形参、构造器内部的变量
 *
 * 		2.2 关于权限修饰符的不同
 * 		属性:可以在声明属性时，指明其权限，使用权限修饰符。
 * 			常用的权限修饰符:private、public、缺省、protected
 * 			目前声明属性时，都使用缺省即可。
 * 		局部变量:不可以使用权限修饰符。
 *
 * 		2.3 默认初始化值的情况:
 * 		属性:类的属性，根据其类型，都有默认初始化值。
 * 			整型(byte、short、int、long):0
 * 			浮点型(float、double):0.0
 * 			字符型(char):0(或‘\u0000’)
 * 			布尔型(boolean):false
 *
 * 			引用数据类型(类、数组、接口):null
 *
 * 		局部变量:没有默认初始化值
 * 			意味着:在调用局部变量之前，一定要显式赋值。
 * 			特别地:形参在调用时,赋值即可。例，45 行
 *
 * 		2.4 在内存中加载的位置，亦各不相同。
 * 		属性:加载到堆空间中(非 static)
 * 		局部变量:加载到栈空间
 */
public class UserTest {
	public static void main(String[] args) {
		User u1 = new User();
		System.out.println(u1.name);
		System.out.println(u1.age);
		System.out.println(u1.isMale);

		u1.talk("俄语");
	}
}
class User{
	//属性(或成员变量)
	String name;	//不加 private 即为缺省
	public int age;	//不加 public 即为缺省
	boolean isMale;

	public void talk(String language){//language:形参，也是局部变量
		System.out.println("我们使用" + language + "进行交流。");
	}

	public void eat(){
		String food = "石头饼";	//石头饼:局部变量
		System.out.println("北方人喜欢吃:" + food);
	}
}
```

> 1、练习1

```java
/*
编写教师类和学生类，并通过测试类创建对象进行测试
Student类
属性:
name:String age:int major:String interests:String
方法:say() 返回学生的个人信息
Teacher类
属性:
name:String age:int teachAge:int course:String
方法:say() 输出教师的个人信息
*/
public class School {
	public static void main(String[] args) {
		Student stu = new Student();
        stu.name = "小明";
        stu.age = 16;

		Teacher tea = new Teacher();
		tea.name = "王老师";
        tea.age = 27;

        tea.say(stu.name,stu.age);
        stu.say(tea.name, tea.age);
	}
}
class Student{
	String name;
	int age;
	String major;
	String interests;

	void say(String name, int age){
		System.out.println("这个学生是："+name+"年龄是："+age);	}
}
class Teacher{
	String name;
	int age;
	String teachAge;
	String course;

	void say(String name, int age){
		System.out.println("这个老师是："+name+"年龄是："+age);
	}
}
```

## 04、 类的成员之二：方法

### 4.1、类中方法的声明和使用

```java
/*
 * 类中方法的声明和使用
 *
 * 方法：描述类应该具有的功能。
 * 比如：Math类：sqrt()\random() \...
 *     Scanner类：nextXxx() ...
 *     Arrays类：sort() \ binarySearch() \ toString() \ equals() \ ...
 *
 * 1.举例：
 * public void eat(){}
 * public void sleep(int hour){}
 * public String getName(){}
 * public String getNation(String nation){}
 *
 * 2. 方法的声明：权限修饰符  返回值类型  方法名(形参列表){
 * 					方法体
 * 			  }
 *   注意：static、final、abstract 来修饰的方法，后面再讲。
 *
 * 3. 说明：
 * 		3.1 关于权限修饰符：默认方法的权限修饰符先都使用public
 * 			Java规定的4种权限修饰符：private、public、缺省、protected  -->封装性再细说
 *
 * 		3.2 返回值类型： 有返回值  vs 没有返回值
 * 			3.2.1  如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用
 *                return关键字来返回指定类型的变量或常量：“return 数据”。
 * 				  如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要
 *               使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。
 *
 * 			3.2.2 我们定义方法该不该有返回值？
 * 				① 题目要求
 * 				② 凭经验：具体问题具体分析
 *
 *      3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”
 *      3.4 形参列表:方法名可以声明0个、1个，或多个形参。
 *      	3.4.1 格式:数据类型1 形参1，数据类型2 形参2,...
 *
 *      	3.4.2 我们定义方法时，该不该定义形参？
 *      		① 题目要求
 *      		② 凭经验，具体问题具体分析
 *      3.5 方法体:方法功能的体现。
 *  4. return关键字的使用：
 *  	1.使用范围:使用在方法体中
 *  	2.作业:① 结束方法
 *  		  ② 针对于有返回值类型的方法，使用"return 数据"方法返回所要的数据。
 *  	3.注意点:return关键字后不可声明执行语句。
 *  5. 方法的使用中，可以调用当前类的属性或方法。
 *  		特殊的:方法A中又调用了方法A:递归方法。
 *  	方法中不能定义其他方法。
 */
public class CustomerTest {
	public static void main(String[] args) {

		Customer cust1 = new Customer();

		cust1.eat();

		//测试形参是否需要设置的问题
//		int[] arr = new int[]{3,4,5,2,5};
//		cust1.sort();

		cust1.sleep(8);

	}
}
//客户类
class Customer{

	//属性
	String name;
	int age;
	boolean isMale;

	//方法
	public void eat(){
		System.out.println("客户吃饭");
		return;
		//return后不可以声明表达式
//		System.out.println("hello");
	}

	public void sleep(int hour){
		System.out.println("休息了" + hour + "个小时");

		eat();
//		sleep(10);
	}

	public String getName(){

		if(age > 18){
			return name;

		}else{
			return "Tom";
		}
	}

	public String getNation(String nation){
		String info = "我的国籍是：" + nation;
		return info;
	}

	//体会形参是否需要设置的问题
//	public void sort(int[] arr){
//
//	}
//	public void sort(){
//		int[] arr = new int[]{3,4,5,2,5,63,2,5};
//		//。。。。
//	}

	public void info(){
		//错误的
//		public void swim(){
//
//		}

	}
}
```

> 1、练习1

创建一个Person类，其定义如下：

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/6911778e7f45ba2b3131c9e970544582.png)

```java
public class Person {
	String name;
	int age;
	/*
	 * sex:1表示为男性
	 * sex:0表示为女性
	 */
	int sex;

	public void study(){
		System.out.println("studying");
	}

	public void showAge(){
		System.out.println("age:" + age);
	}

	public int addAge(int i){
		age += i;
		return age;
	}
}
```

测试类

```java
/*
 * 要求:
 * (1)创建Person类的对象，设置该对象的name、age和sex属性，
 * 	调用study方法，输出字符串“studying”，
 * 	调用showAge()方法显示age值，
 * 	调用addAge()方法给对象的age属性值增加2岁。
 * (2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。
 *
 */
public class PersonTest {
	public static void main(String[] args) {
		Person p1 = new Person();

		p1.name = "Tom";
		p1.age = 18;
		p1.sex = 1;

		p1.study();

		p1.showAge();

		int newAge = p1.addAge(2);
		System.out.println(p1.name + "的年龄为" + newAge);

		System.out.println(p1.age);	//20

		//*******************************
		Person p2 = new Person();
		p2.showAge();	//0
		p2.addAge(10);
		p2.showAge();	//10

		p1.showAge();	//20
	}
}
```

> 2、练习2

```java
/*
 * 2.利用面向对象的编程方法，设计类Circle计算圆的面积。
 */
//测试类
public class CircleTest {
	public static void main(String[] args) {
		Circle c1 = new Circle();

		c1.radius = 2.1;

		//对应方式一:
//		double area = c1.findArea();
//		System.out.println(area);

		//对应方式二:
		c1.findArea();
		//错误的调用
		double area = c1.findArea(3.4);
		System.out.println(area);
	}
}
//圆:3.14*r*r
class Circle{
	//属性
	double radius;

	//圆的面积方法
	//方法1：
//	public double findArea(){
//		double area = 3.14 * radius * radius;
//		return area;
//	}
	//方法2：
	public void findArea(){
		double area = Math.PI * radius * radius;
		System.out.println("面积为:" + area);
	}
	//错误情况:
	public double findArea(Double r){
		double area = 3.14 * r * r;
		return area;
	}
}
```

> 3、练习3

```java
/*
 * 3.1 编写程序，声明一个method方法，在方法中打印一个10*8的*型矩形，在main方法中调用该方法。
 * 3.2修改上一个程序，在method方法中，除打印一个10*8的*型矩形外，再计算该矩形的面积，
 * 并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。
 *
 * 3.3 修改上一个程序，在method方法提供m和n两个参数，方法中打印一个m*n的*型矩形，
 * 并计算该矩形的面积，将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。
 *
 */
public class ExerTest {

	public static void main(String[] args) {

		ExerTest esr = new ExerTest();
		//3.1测试
//		esr.method();

		//3.2测试
		//方式一：
//		int area = esr.method();
//		System.out.println("面积为:" + area);

		//方式二:
//		System.out.println("面积为:" + esr.method());

		//3.3测试
		System.out.println("面积为:" + esr.method(6,5));
	}
	//3.1
//	public void method(){
//		for(int i = 0;i < 10;i++){
//			for(int j = 0;j < 8;j++){
//				System.out.print("* ");
//			}
//			System.out.println();
//		}
//	}

	//3.2
//	public int method(){
//		for(int i = 0;i < 10;i++){
//			for(int j = 0;j < 8;j++){
//				System.out.print("* ");
//			}
//			System.out.println();
//		}
//		return 10 * 8;
//	}

	//3.3
	public int method(int m,int n){
		for(int i = 0;i < m;i++){
			for(int j = 0;j < n;j++){
				System.out.print("* ");
			}
			System.out.println();
		}
		return m * n;
	}
}
```

> 4、练习四

```java
/*
 * 4. 对象数组题目：定义类Student，包含三个属性：
 * 学号number(int)，年级state(int)，成绩score(int)。
 * 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。
 * 问题一：打印出3年级(state值为3）的学生信息。
 * 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息
 * 提示：  1) 生成随机数：Math.random()，返回值类型double;
 * 		2) 四舍五入取整：Math.round(double d)，返回值类型long。
 *
 */
public class StudentTest {
	public static void main(String[] args) {
		//声明一个Student类型的数组
		Student[] stu = new Student[20];

		for(int i = 0;i <stu.length;i++){
			//给数组元素赋值
			stu[i] = new Student();
			//给Student的对象的属性赋值
			stu[i].number = i + 1;
			//年级:[1,6]
			stu[i].state = (int)(Math.random() * (6 - 1 + 1) + 1);
			//成绩:[0,100]
			stu[i].score = (int)(Math.random() * (100 - 0 + 1));
		}

		//遍历学生数组
		for(int i = 0;i < stu.length;i++){
//			System.out.println(stu[i].number + "," + stu[i].state
//				+  "," + stu[i].score);

			System.out.println(stu[i].info());
		}
		System.out.println("*********以下是问题1*********");

		//问题一：打印出3年级(state值为3）的学生信息。
		for(int i = 0;i < stu.length;i++){
			if(stu[i].state == 3){
				System.out.println(stu[i].info());
			}
		}
		System.out.println("********以下是问题2**********");

		//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息。
		for(int i = 0;i < stu.length - 1;i++){
			for(int j = 0;j <stu.length - 1 - i;j++){
				if(stu[j].score >stu[j+1].score){
					//如果需要换序，交换的是数组的元素，Student对象！！！
					Student temp = stu[j];
					stu[j] = stu[j+1];
					stu[j+1] = temp;
				}
			}
		}

		//遍历学生数组
		for(int i = 0;i < stu.length;i++){
			System.out.println(stu[i].info());
		}

	}
}
class Student{
	int number;	//学号
	int state;	//年级
	int score;	//成绩

	//显示学生信息的方法
	public String info(){
		return "学号:" + number + ",年级:" + state + ",成绩:" + score;
	}
}
```

> 4-1、练习四优化

```java
/*
 * 4. 对象数组题目：定义类Student，包含三个属性：
 * 学号number(int)，年级state(int)，成绩score(int)。
 * 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。
 * 问题一：打印出3年级(state值为3）的学生信息。
 * 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息
 * 提示：  1) 生成随机数：Math.random()，返回值类型double;
 * 		2) 四舍五入取整：Math.round(double d)，返回值类型long。
 *
 * 此代码是对StudentTest.java的改进，将操作数组的功能封装到方法中。
 */
public class StudentTest2 {
	public static void main(String[] args) {
		//声明一个Student类型的数组
		Student2[] stu = new Student2[20];

		for(int i = 0;i <stu.length;i++){
			//给数组元素赋值
			stu[i] = new Student2();
			//给Student的对象的属性赋值
			stu[i].number = i + 1;
			//年级:[1,6]
			stu[i].state = (int)(Math.random() * (6 - 1 + 1) + 1);
			//成绩:[0,100]
			stu[i].score = (int)(Math.random() * (100 - 0 + 1));
		}

		StudentTest2 test = new StudentTest2();

		//遍历学生数组
		test.print(stu);

		System.out.println("*********以下是问题1*********");

		//问题一：打印出3年级(state值为3）的学生信息。
		test.searchState(stu, 3);
		System.out.println("********以下是问题2**********");

		//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息。
		test.sort(stu);

		//遍历学生数组
		for(int i = 0;i < stu.length;i++){
			System.out.println(stu[i].info());
		}
	}

	/**
	  *
	  * @Description 遍历Student[]数组的操作
	 */
	public void print(Student2[] stu){
		for(int i = 0;i < stu.length;i++){
			System.out.println(stu[i].info());
		}
	}

	/**
	  *
	  * @Description 查找Student数组中指定年级的学习信息
	 */
	public void searchState(Student2[] stu,int state){
		for(int i = 0;i < stu.length;i++){
			if(stu[i].state == state){
				System.out.println(stu[i].info());
			}
		}
	}

	/**
	  *
	  * @Description 给Student数组排序
	 */
	public void sort(Student2[] stu){
		for(int i = 0;i < stu.length - 1;i++){
			for(int j = 0;j <stu.length - 1 - i;j++){
				if(stu[j].score >stu[j+1].score){
					//如果需要换序，交换的是数组的元素，Student对象！！！
					Student2 temp = stu[j];
					stu[j] = stu[j+1];
					stu[j+1] = temp;
				}
			}
		}
	}
}
class Student2{
	int number;	//学号
	int state;	//年级
	int score;	//成绩

	//显示学生信息的方法
	public String info(){
		return "学号:" + number + ",年级:" + state + ",成绩:" + score;
	}
}
```

### 4.2、理解“万事万物皆对象”

```java
/* 1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构。
 * 		》Scanner,String等
 * 		》文件：File
 * 		》网络资源：URL
 * 2.涉及到Java语言与前端html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。
 */
```

### 4.3、对象数组的内存解析

```java
/*引用类型的变量，只可能存储量两类值：null或地址值（含变量类型）*/
Student[] stus= newStudent[5];
stus[0] = new Student();
sysout(stus[0].state);//1
sysout(stus[1]);//null
sysout(stus[1].number);//异常
stus[1] = new Student();
sysout(stus[1].number);//0

class Student{
  int number;//学号
  int state = 1;//年级
  int score;//成绩
}
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/b076c453b52bf6f3643b8cfc66809c25.png)

### 4.4、匿名对象的使用

```java
/*
 * 三、匿名对象的使用
 * 1.理解:我们创建的对象，没有显示的赋值给一个变量名。即为匿名对象。
 * 2.特征：匿名对象只能调用一次。
 * 3.使用:如下
 */
public class InstanceTest {
	public static void main(String[] args) {
		Phone p = new Phone();
//		p = null;
		System.out.println(p);

		p.sendEmail();
		p.playGame();

		//匿名对象
//		new Phone().sendEmail();
//		new Phone().playGame();

		new Phone().price = 1999;
		new Phone().showPrice();	//0.0

		//*******************************
		PhoneMall mall = new PhoneMall();
//		mall.show(p);
		//匿名对象的使用
		mall.show(new Phone());
	}
}

class PhoneMall{

	public void show(Phone phone){
		phone.sendEmail();
		phone.playGame();
	}
}

class Phone{
	double price;	//价格

	public void sendEmail(){
		System.out.println("发邮件");
	}
	public void playGame(){
		System.out.println("打游戏");
	}
	public void showPrice(){
		System.out.println("手机价格为:" + price);
	}
}
```

### 4.5、自定义数组的工具类

> 1、**工具类**

```java
/*
 * 自定义数组工具类
 */
public class ArrayUtil {

	// 求数组的最大值
	public int getMax(int[] arr) {
		int maxValue = arr[0];
		for (int i = 1; i < arr.length; i++) {
			if (maxValue < arr[i]) {
				maxValue = arr[i];
			}
		}
		return maxValue;
	}

	// 求数组的最小值
	public int getMin(int[] arr) {
		int minValue = arr[0];
		for (int i = 1; i < arr.length; i++) {
			if (minValue > arr[i]) {
				minValue = arr[i];
			}
		}
		return minValue;
	}

	// 求数组总和
	public int getSum(int[] arr) {
		int sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return sum;
	}

	// 求数组平均值
	public int getAvg(int[] arr) {
		int avgValue = getSum(arr) / arr.length;
		return avgValue;
	}

	// 反转数组
	public void reverse(int[] arr) {
		for (int i = 0; i < arr.length / 2; i++) {
			int temp = arr[i];
			arr[i] = arr[arr.length - i - 1];
			arr[arr.length - i - 1] = temp;
		}
	}

	// 复制数组
	public int[] copy(int[] arr) {
		int[] arr1 = new int[arr.length];
		for (int i = 0; i < arr1.length; i++) {
			arr1[i] = arr[i];
		}
		return null;
	}

	// 数组排序
	public void sort(int[] arr) {
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 0; j < arr.length - 1 - i; j++) {
				if (arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
	}

	// 遍历数组
	public void print(int[] arr) {
		System.out.print("[");
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + ",");
		}
		System.out.println("]");
	}

	// 查找指定元素
	public int getIndex(int[] arr, int dest) {
		//线性查找
		for (int i = 0; i < arr.length; i++) {
			if (dest==arr[i]) {
				return i;
			}
		}
		return -1;
	}
}
```

> 2、**测试类**

```java
/**
  * @Description 测试类
  *
 */
public class ArrayUtilTest {

	public static void main(String[] args) {
		ArrayUtil util = new ArrayUtil();
		int[] arr = new int[]{32,5,26,74,0,96,14,-98,25};
		int max = util.getMax(arr);
		System.out.println("最大值为:" + max);

//		System.out.print("排序前:");
//		util.print(arr);
//
//		util.sort(arr);
//		System.out.print("排序后:");
//		util.print(arr);

		System.out.println("查找:");
		int index = util.getIndex(arr, 5);
		if(index > 0){
			System.out.println("找到了，索引地址:" + index);
		}else{
			System.out.println("没找到");
		}
	}
}
```

### 4.6、方法的重载(overload)

```java
/*
 * 方法的重载(overload) loading...
 *
 * 1.定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
 *
 * 		“两同一不同”:同一个类、相同方法名
 * 				  参数列表不同：参数个数不同，参数类型不同
 *
 * 2.举例:
 * 		Arrays类中重载的sort() / binarySearch()
 *
 * 3.判断是否重载
 * 		与方法的返回值类型、权限修饰符、形参变量名、方法体都无关。
 *
 * 4.在通过对象调用方法时，如何确定某一个指定的方法：
 * 		方法名---》参数列表
 */
public class OverLoadTest {

	public static void main(String[] args) {
		OverLoadTest test = new OverLoadTest();
		test.getSum(1, 2);	//调用的第一个，输出1
	}

	//如下的四个方法构成了重载
	public void getSum(int i,int j){
		System.out.println("1");
	}
	public void getSum(double d1,double d2){
		System.out.println("2");
	}
	public void getSum(String s,int i){
		System.out.println("3");
	}

	public void getSum(int i,String s){

	}

	//以下3个是错误的重载
//	public int getSum(int i,int j){
//		return 0;
//	}

//	public void getSum(int m,int n){
//
//	}

//	private void getSum(int i,int j){
//
//	}
}
```

> 1、**举例**

```java
1.判断：与void show(int a,char b,double c){}构成重载的有：

a)void show(int x,char y,double z){} // no
b)int show(int a,double c,char b){} // yes
c) void show(int a,double c,char b){} // yes
d) boolean show(int c,char b){} // yes
e) void show(double c){} // yes
f) double show(int x,char y,double z){} // no
g) void shows(){double c} // no
```

> 2、**编程**

```java
/*
 * 1.编写程序，定义三个重载方法并调用。方法名为mOL。
 * 三个方法分别接收一个int参数、两个int参数、一个字符串参数。
 * 分别执行平方运算并输出结果，相乘并输出结果，输出字符串信息。
 * 在主类的main ()方法中分别用参数区别调用三个方法。
 * 2.定义三个重载方法max()，
 * 第一个方法求两个int值中的最大值，
 * 第二个方法求两个double值中的最大值，
 * 第三个方法求三个double值中的最大值，并分别调用三个方法。
 *
 */
public class OverLoadever {

	public static void main(String[] args) {
		OverLoadever test = new OverLoadever();
		//1.调用3个方法
		test.mOL(5);
		test.mOL(6, 4);
		test.mOL("fg");

		//2.调用3个方法
		int num1 = test.max(18, 452);
		System.out.println(num1);
		double num2 = test.max(5.6, -78.6);
		System.out.println(num2);
		double num3 = test.max(15, 52, 42);
		System.out.println(num3);
	}

	//1.如下三个方法构成重载
	public void mOL(int i){
		System.out.println(i*i);
	}
	public void mOL(int i,int j){
		System.out.println(i*j);
	}
	public void mOL(String s){
		System.out.println(s);
	}

	//2.如下三个方法构成重载
	public int max(int i,int j){
		return (i > j) ? i : j;
	}
	public double max(double i,double j){
		return (i > j) ? i : j;
	}
	public double max(double d1,double d2,double d3){
		double max = (d1 > d2) ? d1 : d2;
		return (max > d3) ? max : d3;
	}
}
```

### 4.7、可变个数的形参

JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许`直接定义能和多个实参相匹配的形参`。从而，可以用一种更简单的方式，来传递个数可变的实参。

```java
/*
 * 可变个数形参的方法
 * 1.jdk 5.0新增的内容
 * 2.具体使用：
 * 	2.1 可变个数形参的格式：数据类型 ... 变量名
 * 	2.2 当调用可变个数形参的方法时，传入的参数的个数可以是：0个，1个，2个...
 * 	2.3可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。
 *  2.4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。即二者不可共存。
 *  2.5可变个数形参在方法中的形参中,必须声明在末尾。
 *  2.6可变个数形参在方法中的形参中，最多只能声明一个可变形参。
 */
public class MethodArgs {

	public static void main(String[] args) {
		MethodArgs test = new MethodArgs();
		test.show(12);
		// test.show("hell0");
		// test.show("hello","world");
		// test.show();

		test.show(new String[] { "AA", "BB", "CC" });
	}

	public void show(int i) {

	}

	// public void show(String s){
	// System.out.println("show(String)");
	// }
	public void show(String... strs) {
		System.out.println("show(String ...strs)");

		for (int i = 0; i < strs.length; i++) {
			System.out.println(strs[i]);
		}
	}

	// 此方法与上一方法不可共存
	// public void show(String[] strs){
	//
	// }

	public void show(int i, String... strs) {

	}

	//The variable argument type String of the method show must be the last parameter
//	public void show(String... strs,int i,) {
//
//	}
}
```

### 4.8、方法参数的值传递机制(重点！！！)

```java
/*
 * 关于变量的赋值
 *
 * 	如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
 * 	如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。
 *
 */
public class ValueTransferTest {

	public static void main(String[] args) {

		System.out.println("**********基本数据类型：***********");
		int m = 10;
		int n = m;

		System.out.println("m = " + m + ", n = " + n);

		n = 20;

		System.out.println("m = " + m + ", n = " + n);

		System.out.println("***********引用数据类型:********");

		Order o1 = new Order();
		o1.orderId = 1001;

		Order o2 = o1;	//赋值后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体
		System.out.println("o1.orderId = " + o1.orderId + ",o2.orderId = " + o2.orderId);

		o2.orderId = 1002;
		System.out.println("o1.orderId = " + o1.orderId + ",o2.orderId = " + o2.orderId);

	}
}

class Order{
	int orderId;
}
```

#### 4.8.1、**针对基本数据类型**

```java
/*
 * 方法的形参的传递机制：值传递
 *
 * 1.形参：方法定义时，声明的小括号内的参数
 *   实参：方法调用时，实际传递给形参的数据
 *
 * 2.值传递机制：
 *  如果参数是基本数据类型，此时实参赋值给形参的是实参真是存储的数据值。
 */
public class ValueTransferTest1 {

	public static void main(String[] args) {

		int m = 10;
		int n = 20;

		System.out.println("m = " + m + ", n = " + n);
		//交换两个变量的值的操作
//		int temp = m;
//		m = n;
//		n = temp;

		ValueTransferTest1 test = new ValueTransferTest1();
		test.swap(m, n);

		System.out.println("m = " + m + ", n = " + n);

	}

	public void swap(int m,int n){
		int temp = m;
		m = n;
		n = temp;
	}
}
```

![](https://gitee.com/lsqpic/BlogPicBed-1/raw/master/img/2021/01/28/20210131185954)

#### 4.8.2、**针对引用数据类型**

```java
/*
 *  如果参数是引用数据类型，此时实参赋值给形参的是实参存储数据的地址值。
 */
public class ValueTransferTest2 {

	public static void main(String[] args) {
		Data data = new Data();

		data.m = 10;
		data.n = 20;

		System.out.println("m = " + data.m + ", n = " + data.n);

		//交换m和n的值
//		int temp = data.m;
//		data.m = data.n;
//		data.n = temp;

		ValueTransferTest2 test = new ValueTransferTest2();
		test.swap(data);

		System.out.println("m = " + data.m + ", n = " + data.n);

	}

	public void swap(Data data){
		int temp = data.m;
		data.m = data.n;
		data.n = temp;
	}
}

class Data{

	int m;
	int n;
}
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/4e2fc6b32f4a88bd95ddc2691f84d3e0.png)

#### 4.8.3、**练习1**

```java
public class TransferTest3{
	public static void main(String args[]){
		TransferTest3 test=new TransferTest3();
		test.first();
	}

	public void first(){
		int i=5;
		Value v=new Value();
		v.i=25;
		second(v,i);
		System.out.println(v.i);
	}

	public void second(Value v,int i){
		i=0;
		v.i=20;
		Value val=new Value();
		v=val;
		System.out.println(v.i+" "+i);

	}
}
class Value {
	int i= 15;
}
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/beae8aceffb02040a75f507e5f740b90.png)

#### 4.8.4、**练习2**

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/435f302831c0ca1b9cebff25ac099693.png)

```java
public static void method(int a,int b){
	a = a * 10;
	b = b * 20;
	System.out.println(a);
	System.out.println(b);
	System.exit(0);
}
```

#### 4.8.5、**练习3**

```java
/*
 * 微软：
 * 定义一个int型的数组：int[] arr = new int[]{12,3,3,34,56,77,432};
 * 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的新值。遍历新的数组。
 */

//错误写法
for(int i= 0;i < arr.length;i++){
	arr[i] = arr[i] / arr[0];
}

//正确写法1
for(int i = arr.length –1;i >= 0;i--){
	arr[i] = arr[i] / arr[0];
}

//正确写法2
int temp = arr[0];
for(int i= 0;i < arr.length;i++){
	arr[i] = arr[i] / temp;
}
```

#### 4.8.6、**练习4**

```java
/*
 * int[] arr = new int[10];
 * System.out.println(arr);//地址值?
 *
 * char[] arr1 = new char[10];
 * System.out.println(arr1);//地址值?
 */
public class ArrayPrint {

	public static void main(String[] args) {
		int[] arr = new int[]{1,2,3};
        //传进去的是一个Object的对象
		System.out.println(arr);//地址值

		char[] arr1 = new char[]{'a','b','c'};
        //传进去的是一个数组，里面遍历数据了
		System.out.println(arr1);//abc
	}
}
```

#### 4.8.7、**练习5：将对象作为参数传递给方法**

```java
/*
 * 练习5：将对象作为参数传递给方法
 * (1)定义一个Circle类，包含一个double型的radius属性代表圆的半径，一个findArea()方法返回圆的面积。
 *
 * (2)定义一个类PassObject，在类中定义一个方法printAreas()，该方法的定义如下：
 * public void printAreas(Circle c,int time)
 * 在printAreas方法中打印输出1到time之间的每个整数半径值，以及对应的面积。
 * 例如，times为5，则输出半径1，2，3，4，5，以及对应的圆面积。
 *
 * (3)在main方法中调用printAreas()方法，调用完毕后输出当前半径值。
 *
 */
public class Circle {

	double radius;	//半径

	//返回圆的面积
	public double findArea(){
		return radius * radius * Math.PI;
	}
}
```

> **PassObject类**

```java
public class PassObject {

	public static void main(String[] args) {
		PassObject test = new PassObject();

		Circle c = new Circle();

		test.printAreas(c, 5);

		System.out.println("no radius is:" + c.radius);
	}

	public void printAreas(Circle c,int time){

		System.out.println("Radius\t\tAreas");

		//设置圆的半径
		for(int i = 1;i <= time ;i++){
			c.radius = i;
			System.out.println(c.radius + "\t\t" + c.findArea());
		}

		//重新赋值
		c.radius = time + 1;
	}
}
```

### 4.9、递归(recursion)方法

```java
/*
 * 递归方法的使用(了解)
 * 1.递归方法：一个方法体内调用它自身。
 * 2.方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
 *
 * 3.递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。
 *
 */
public class RecursionTest {

	public static void main(String[] args) {

		// 例1:计算1-100之间所有自然数的和
		// 方法1:
		int sum = 0;
		for (int i = 1; i <= 100; i++) {
			sum += i;
		}
		System.out.println("sum = " + sum);

		// 方法2:
		RecursionTest test = new RecursionTest();
		int sum1 = test.getSum(100);
		System.out.println("sum1 = " + sum1);
	}

	// 例1:计算1-n之间所有自然数的和
	public int getSum(int n) {

		if (n == 1) {
			return 1;
		} else {
			return n + getSum(n - 1);
		}
	}

	// 例2:计算1-n之间所有自然数的乘积
	//归求阶乘(n!)的算法
	public int getSum1(int n) {

		if (n == 1) {
			return 1;
		} else {
			return n * getSum1(n - 1);
		}
	}
}
```

> 1、**练习1**

```java
public class RecursionTest {

	public static void main(String[] args) {

		int value = test.f(10);
		System.out.println(value);
	}

	//例3:已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),
	//其中n是大于0的整数，求f(10)的值。
	public int f(int n){
		if(n == 0){
			return 1;
		}else if(n == 1){
			return 4;
		}else{
			return 2*f(n-1) + f(n-2);
		}
	}

	//例4:已知一个数列：f(20) = 1,f(21) = 4,f(n+2) = 2*f(n+1)+f(n),
	//其中n是大于0的整数，求f(10)的值。
	public int f1(int n){
		if(n == 20){
			return 1;
		}else if(n == 21){
			return 4;
		}else{
			return 2*f1(n-1) + f1(n-2);
		}
	}
}
```

> 2、**练习2**

```java
/*
 * 输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值
 * 1  1  2  3  5  8  13  21  34  55
 * 规律：一个数等于前两个数之和
 * 要求：计算斐波那契数列(Fibonacci)的第n个值，并将整个数列打印出来
 *
 */
public class Recursion2 {

	public static void main(String[] args) {

		Recursion2 test = new Recursion2();
		int value = test.f(10);
		System.out.println(value);
	}

	public int f(int n) {

		if (n == 1 || n == 2) {
			return 1;
		} else {
			return f(n - 1) + f(n - 2);
		}
	}
}
```

## 05、面向对象特征之一：封装与隐藏

> 1、封装性的引入与体现

为什么需要封装？封装的作用和含义？
我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？
我要开车，…

> 2、我们程序设计追求“高内聚，低耦合”。

高内聚：类的内部数据操作细节自己完成，不允许外部干涉；
低耦合：仅对外暴露少量的方法用于使用。

> 3、隐藏对象内部的复杂性，只对外公开简单的接口。

便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，**把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。**

```java
/*
 * 面向对象的特征一:封装与隐藏
 * 一、问题的引入：
 *    当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到
 *    属性的数据类型和存储范围的制约。但除此之外，没有其他制约条件。但是，实际问题中，我们往往需要给属性赋值
 *    加入额外限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行条件的添加。比如说，setLegs
 *    同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private)
 *    --》此时，针对于属性就体现了封装性。
 *
 * 二、封装性的体现：
 *    我们将类的属性私有化(private),同时,提供公共的(public)方法来获取(getXxx)和设置(setXxx)
 *
 *    拓展：封装性的体现：① 如上 ② 单例模式 ③ 不对外暴露的私有方法
 *
 */
public class AnimalTest {

	public static void main(String[] args) {
		Animal a = new Animal();
		a.name = "大黄";
//		a.age = 1;
//		a.legs = 4;//The field Animal.legs is not visible

		a.show();

//		a.legs = -4;
//		a.setLegs(6);
		a.setLegs(-6);

//		a.legs = -4;//The field Animal.legs is not visible
		a.show();

		System.out.println(a.name);
		System.out.println(a.getLegs());
	}
}
class Animal{

	String name;
	private int age;
	private int legs; //腿的个数

	//对于属性的设置
	public void setLegs(int l){
		if(l >= 0 && l % 2 == 0){
			legs = l;
		}else{
			legs = 0;
		}
	}

	//对于属性的获取
	public int getLegs(){
		return legs;
	}

	public void eat(){
		System.out.println("动物进食");
	}

	public void show(){
		System.out.println("name = " + name + ",age = " + age + ",legs = " + legs);
	}

	//提供关于属性 age 的 get 和 set 方法
	public int getAge(){
		return age;
	}

	public void setAge(int a){
		age = a;
	}
}
```

### 5.1、四种权限修饰符的理解与测试

Java 权限修饰符`public、protected、default(缺省)、private` 置于类的成员定义前，用来限定对象对该类成员的访问权限。

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/ab992b12ef5b16774376e00dab0415e0.png)

**对于 class 的权限修饰只可以用 public 和 default(缺省)。**

*   public 类可以在任意地方被访问。
*   default 类只可以被同一个包内部的类访问。

> 1、**Order 类**

```java
/*
 * 三、封装性的体现，需要权限修饰符来配合。
 *   1.Java 规定的 4 种权限：(从小到大排序)private、缺省、protected、public
 *   2.4 种权限用来修饰类及类的内部结构：属性、方法、构造器、内部类
 *   3.具体的，4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
 * 		 修饰类的话，只能使用：缺省、public
 *  总结封装性：Java 提供了 4 中权限修饰符来修饰类积累的内部结构，体现类及类的内部结构的可见性的方法。
 *
 */
public class Order {

	private int orderPrivate;
	int orderDefault;
	public int orderPublic;

	private void methodPrivate(){
		orderPrivate = 1;
		orderDefault = 2;
		orderPublic = 3;
	}

	void methodDefault(){
		orderPrivate = 1;
		orderDefault = 2;
		orderPublic = 3;
	}

	public void methodPublic(){
		orderPrivate = 1;
		orderDefault = 2;
		orderPublic = 3;
	}
}
```

> 2、**OrderTest 类**

```java
public class OrderTest {

	public static void main(String[] args) {

		Order order = new Order();

		order.orderDefault = 1;
		order.orderPublic = 2;
		//出了 Order 类之后，私有的结构就不可调用了
//		order.orderPrivate = 3;//The field Order.orderPrivate is not visible

		order.methodDefault();
		order.methodPublic();
		//出了 Order 类之后，私有的结构就不可调用了
//		order.methodPrivate();//The method methodPrivate() from the type Order is not visible
	}
}
```

> **相同项目不同包的 OrderTest 类**

```java
import github.Order;

public class OrderTest {

	public static void main(String[] args) {
		Order order = new Order();

		order.orderPublic = 2;
		//出了 Order 类之后，私有的结构、缺省的声明结构就不可调用了
//		order.orderDefault = 1;
//		order.orderPrivate = 3;//The field Order.orderPrivate is not visible

		order.methodPublic();
		//出了 Order 类之后，私有的结构、缺省的声明结构就不可调用了
//		order.methodDefault();
//		order.methodPrivate();//The method methodPrivate() from the type Order is not visible
	}
}
```

![](https://gitee.com/lsqpic/BlogPicBed-1/raw/master/img/2021/01/28/20210131190033.png)

### 5.2、封装性的练习

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/14df2c230ae124b47badd1df03f7f4ec.png)

```java
/*
 * 1.创建程序,在其中定义两个类：Person 和 PersonTest 类。
 * 定义如下：用 setAge()设置人的合法年龄(0~130)，用 getAge()返回人的年龄。
 *
 */
public class Person {

	private int age;

	public void setAge(int a){
		if(a < 0 || a > 130){
//			throw new RuntimeException("传入的数据据非法");
			System.out.println("传入的数据据非法");
			return;
		}

		age = a;

	}

	public int getAge(){
		return age;
	}

	//绝对不能这样写！！！
	public int doAge(int a){
		age = a;
		return age;
	}
}
```

> 3、**测试类**

```java
/*
 *  在 PersonTest 类中实例化 Person 类的对象 b，
 *  调用 setAge()和 getAge()方法，体会 Java 的封装性。
 */
public class PersonTest {

	public static void main(String[] args) {
		Person p1 = new Person();
//		p1.age = 1;	//编译不通过

		p1.setAge(12);

		System.out.println("年龄为:" + p1.getAge());
	}
}
```

## 06、 构造器(构造方法)

### 6.1、构造器的理解

```java
/*
 * 类的结构之三:构造器(构造方法、constructor)的使用
 * constructor:
 *
 * 一、构造器的作用:
 * 1.创建对象
 * 2.初始化对象的属性
 *
 * 二、说明
 * 1.如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器。
 * 2.定义构造器的格式:
 * 			权限修饰符  类名(形参列表) { }
 * 3.一个类中定义的多个构造器，彼此构成重载。
 * 4.一旦显示的定义了类的构造器之后，系统不再提供默认的空参构造器。
 * 5.一个类中，至少会有一个构造器
 */
public class PersonTest {

	public static void main(String[] args) {
		//创建类的对象:new + 构造器
		Person p = new Person();	//Person()这就是构造器

		p.eat();

		Person p1 = new Person("Tom");
		System.out.println(p1.name);
	}
}
class Person{
	//属性
	String name;
	int age;

	//构造器
	public Person(){
		System.out.println("Person()......");
	}

	public Person(String n){
		name = n;
	}

	public Person(String n,int a){
		name = n;
		age = a;
	}

	//方法
	public void eat(){
		System.out.println("人吃饭");
	}

	public void study(){
		System.out.println("人学习");
	}
}
```

> 1、**练习 1**

```java
/* 2.在前面定义的 Person 类中添加构造器，
 * 利用构造器设置所有人的 age 属性初始值都为 18。
 *
 */
public class Person {

	private int age;

	public Person(){
		age = 18;
	}
}

public class PersonTest {

	public static void main(String[] args) {
		Person p1 = new Person();

		System.out.println("年龄为:" + p1.getAge());
	}
}
```

> 2、**练习 2**

```java
/* 3.修改上题中类和构造器，增加 name 属性,
 *   使得每次创建 Person 对象的同时初始化对象的 age 属性值和 name 属性值。
 */
public class Person {

	private int age;
	private String name;

	public Person(){
		age = 18;
	}

	public Person(String n,int a){
		name = n;
		age = a;
	}

	public void setName(String n){
		name = n;
	}

	public String getName(){
		return name;
	}

	public void setAge(int a){
		if(a < 0 || a > 130){
//			throw new RuntimeException("传入的数据据非法");
			System.out.println("传入的数据据非法");
			return;
		}

		age = a;

	}

	public int getAge(){
		return age;
	}
}

public class PersonTest {

	public static void main(String[] args) {

		Person p2 = new Person("Tom",21);

		System.out.println("name = " + p2.getName() + ",age = " + p2.getAge());
	}
}
```

> 3、**练习 3**

```java
/*
 * 编写两个类，TriAngle 和 TriAngleTest，
 * 其中 TriAngle 类中声明私有的底边长 base 和高 height，同时声明公共方法访问私有变量。
 * 此外，提供类必要的构造器。另一个类中使用这些公共方法，计算三角形的面积。
 *
 */
public class TriAngle {

	private double base;//底边长
	private double height;//高

	public TriAngle(){

	}

	public TriAngle(double b,double h){
		base = b;
		height = h;
	}

	public void setBase(double b){
		base = b;
	}

	public double getBase(){
		return base;
	}

	public void setHeight(double h){
		height = h;
	}

	public double getHeight(){
		return height;
	}
}

public class TriAngleTest {

	public static void main(String[] args) {

		TriAngle t1 = new TriAngle();
		t1.setBase(2.0);
		t1.setHeight(2.5);
//		t1.base = 2.5;//The field TriAngle.base is not visible
//		t1.height = 4.3;
		System.out.println("base : " + t1.getBase() + ",height : " + t1.getHeight());

		TriAngle t2 = new TriAngle(5.1,5.6);
		System.out.println("面积 : " + t2.getBase() * t2.getHeight() / 2);

	}
}
```

### 6.2、总结属性赋值的过程

```java
/*
 * 总结:属性赋值的先后顺序
 *
 * ① 默认初始化值
 * ② 显式初始化
 * ③ 构造器中赋值
 * ④ 通过"对象.方法" 或 “对象.属性”的方式，赋值
 *
 * 以上操作的先后顺序:① - ② - ③ - ④
 *
 */
public class UserTest {

	public static void main(String[] args) {
		User u = new User();

		System.out.println(u.age);

		User u1 = new User(2);

		u1.setAge(3);

		System.out.println(u1.age);
	}
}
class User{
	String name;
	int age = 1;

	public User(){

	}

	public User(int a){
		age = a;
	}

	public void setAge(int a){
		age = a;
	}
}
```

### 6.3、JavaBean 的使用

```java
/*
 * JavaBean 是一种 Java 语言写成的可重用组件。
 * 所谓 javaBean，是指符合如下标准的 Java 类：
 * 		> 类是公共的
 * 		> 有一个无参的公共的构造器
 * 		> 有属性，且有对应的 get、set 方法
 *
 */
public class Customer {

	private int id;
	private String name;

	public Customer(){

	}

	public void setId(int i){
		id = i;
	}

	public int getId(){
		return id;
	}

	public void setName(String n){
		name = n;
	}

	public String getName(){
		return name;
	}
}
```

### 6.4、UML 类图

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/4245a65d9610ec85f6b80c6f520d989e.png)

*   表示 public 类型，-表示 private 类型，#表示 protected 类型
*   方法的写法: 方法的类型(+、-) 方法名(参数名：参数类型)：返回值类型

## 07、关键字：this 的使用

### 7.1、this 调用属性、方法、构造器

```java
/*
 * this 关键字的使用
 * 1.this 用来修饰、调用：属性、方法、构造器
 *
 * 2.this 修饰属性和方法:
 * 		this 理解为：当前对象,或当前正在创建的对象。
 *
 *  2.1 在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性和方法。
 *  	通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名，我们必须显式
 *  	的使用"this.变量"的方式，表明此变量是属性，而非形参。
 *
 *  2.2 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用正在创建的对象属性和方法。
 *  	但是，通常情况下，我们都选择省略“this.”。特殊情况下，如果构造器的形参和类的属性同名，我们必须显式
 *  	的使用"this.变量"的方式，表明此变量是属性，而非形参。
 *
 *  3.this 调用构造器
 *  	① 我们可以在类的构造器中，显式的使用"this(形参列表)"的方式，调用本类中重载的其他的构造器！
 *  	② 构造器中不能通过"this(形参列表)"的方式调用自己。
 *  	③ 如果一个类中声明了n个构造器，则最多有n -1个构造器中使用了"this(形参列表)"。
 *  	④ "this(形参列表)"必须声明在类的构造器的首行！
 *  	⑤ 在类的一个构造器中，最多只能声明一个"this(形参列表)"。
 */
public class PersonTest {

	public static void main(String[] args) {
		Person p1 = new Person();

		p1.setAge(1);
		System.out.println(p1.getAge());

		p1.eat();
		System.out.println();

		Person p2 = new Person("jerry" ,20);
		System.out.println(p2.getAge());
	}
}
class Person{

	private String name;
	private int age;

	public Person(){
		this.eat();
		String info = "Person 初始化时，需要考虑如下的 1,2,3,4...(共 40 行代码)";
		System.out.println(info);
	}

	public Person(String name){
		this();
		this.name = name;
	}

	public Person(int age){
		this();
		this.age = age;
	}

	public Person(String name,int age){
		this(age);	//调用构造器的一种方式
		this.name = name;
//		this.age = age;
	}

	public void setNmea(String name){
		this.name = name;
	}

	public String getName(){
		return this.name;
	}

	public void setAge(int age){
		this.age = age;
	}

	public int getAge(){
		return this.age;
	}

	public void eat(){
		System.out.println("人吃饭");
		this.study();
	}

	public void study(){
		System.out.println("学习");
	}
}
```

### 7.2、this 的练习

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/d806071ae40c28f681eb09446130c886.png)

> 1、**Boy 类**

```java
public class Boy {

	private String name;
	private int age;

	public void setName(String name){
		this.name = name;
	}

	public String getName(){
		return name;
	}

	public void setAge(int ahe){
		this.age = age;
	}

	public int getAge(){
		return age;
	}

	public Boy(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void marry(Girl girl){
		System.out.println("我想娶" + girl.getName());
	}

	public void shout(){
		if(this.age >= 22){
			System.out.println("可以考虑结婚");
		}else{
			System.out.println("好好学习");
		}
	}
}
```

> 2、**Girl 类**

```java
public class Girl {

	private String name;
	private int age;

	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

	public Girl(){

	}
	public Girl(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public void marry(Boy boy){
		System.out.println("我想嫁给" + boy.getName());
	}
	/**
	  *
	  * @Description 比较两个对象的大小
	  * @author subei
	  * @date 2020 年 4 月 21 日上午 9:17:35
	  * @param girl
	  * @return
	 */
	public int compare(Girl girl){
//		if(this.age >girl.age){
//			return 1;
//		}else if(this.age < girl.age){
//			return -1;
//		}else{
//			return 0;
//		}

		return this.age - girl.age;
	}

}
```

> 3、**测试类**

```java
public class BoyGirlTest {

	public static void main(String[] args) {

		Boy boy = new Boy("罗密欧",21);
		boy.shout();

		Girl girl = new Girl("朱丽叶", 18);
		girl.marry(boy);

		Girl girl1 = new Girl("祝英台", 19);
		int compare = girl.compare(girl1);
		if(compare > 0){
			System.out.println(girl.getName() + "大");
		}else if(compare < 0){
			System.out.println(girl1.getName() + "大");
		}else{
			System.out.println("一样的");
		}
	}
}
```

> 2、练习2

**Account 类**

```java
public class Account {

	private int id; // 账号
	private double balance; // 余额
	private double annualInterestRate; // 年利率

	public void setId(int id) {

	}

	public double getBalance() {
		return balance;
	}

	public void setBalance(double balance) {
		this.balance = balance;
	}

	public double getAnnualInterestRate() {
		return annualInterestRate;
	}

	public void setAnnualInterestRate(double annualInterestRate) {
		this.annualInterestRate = annualInterestRate;
	}

	public int getId() {
		return id;
	}

	public void withdraw(double amount) { // 取钱
		if(balance < amount){
			System.out.println("余额不足，取款失败");
			return;
		}
		balance -= amount;
		System.out.println("成功取出" + amount);
	}

	public void deposit(double amount) { // 存钱
		if(amount > 0){
			balance += amount;
			System.out.println("成功存入" + amount);
		}
	}

	public Account(int id, double balance, double annualInterestRate) {
		this.id = id;
		this.balance = balance;
		this.annualInterestRate = annualInterestRate;
	}


}
```

**Customer 类**

```java
public class Customer {

	private String firstName;
	private String lastName;
	private Account account;

	public Customer(String f, String l) {
		this.firstName = f;
		this.lastName = l;
	}

	public String getFirstName() {
		return firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public Account getAccount() {
		return account;
	}

	public void setAccount(Account account) {
		this.account = account;
	}

}
```

**CustomerTest 类**

```java
/*
 * 写一个测试程序。
 * （1）创建一个 Customer，名字叫 Jane Smith, 他有一个账号为 1000，
 * 余额为 2000 元，年利率为 1.23％的账户。
 * （2）对 Jane Smith 操作。存入 100 元，再取出 960 元。再取出 2000 元。
 * 打印出 Jane Smith 的基本信息
 *
 * 成功存入：100.0
 * 成功取出：960.0
 * 余额不足，取款失败
 * Customer  [Smith,  Jane]  has  a  account:  id  is 1000,
 *  annualInterestRate  is 1.23％,  balance  is 1140.0
 *
 */
public class CustomerTest {

	public static void main(String[] args) {
		Customer cust = new Customer("Jane" , "Smith");

		Account acct = new Account(1000,2000,0.0123);

		cust.setAccount(acct);

		cust.getAccount().deposit(100); //存入 100
		cust.getAccount().withdraw(960); //取钱 960
		cust.getAccount().withdraw(2000); //取钱 2000

		System.out.println("Customer[" + cust.getLastName() + cust.getFirstName() + "]  has  a  account:  id  is "
				+ cust.getAccount().getId() + ",annualInterestRate  is " + cust.getAccount().getAnnualInterestRate() * 100 + "%,  balance  is "
				+ cust.getAccount().getBalance());
	}
}
```

> 3、练习3

**Account 类**

```java
public class Account {

	private double balance;

	public double getBalance() {
		return balance;
	}

	public Account(double init_balance){
		this.balance = init_balance;
	}

	//存钱操作
	public void deposit(double amt){
		if(amt > 0){
			balance += amt;
			System.out.println("存钱成功");
		}
	}

	//取钱操作
	public void withdraw(double amt){
		if(balance >= amt){
			balance -= amt;
			System.out.println("取钱成功");
		}else{
			System.out.println("余额不足");
		}
	}
}
```

**Customer 类**

```java
public class Customer {

	private String firstName;
	private String lastName;
	private Account account;

	public String getFirstName() {
		return firstName;
	}
	public String getLastName() {
		return lastName;
	}
	public Account getAccount() {
		return account;
	}
	public void setAccount(Account account) {
		this.account = account;
	}
	public Customer(String f, String l) {
		this.firstName = f;
		this.lastName = l;
	}
}
```

**Bank 类**

```java
public class Bank {

	private int numberOfCustomers;	//记录客户的个数
	private Customer[] customers;	//存放多个客户的数组

	public Bank(){
		customers = new Customer[10];
	}

	//添加客户
	public void addCustomer(String f,String l){
		Customer cust = new Customer(f,l);
//		customers[numberOfCustomers] = cust;
//		numberOfCustomers++;
		customers[numberOfCustomers++] = cust;
	}

	//获取客户的个数
	public int getNumberOfCustomers() {
		return numberOfCustomers;
	}

	//获取指定位置上的客户
	public Customer getCustomers(int index) {
//		return customers;	//可能报异常
		if(index >= 0 && index < numberOfCustomers){
			return customers[index];
		}

		return null;
	}

}
```

**BankTest 类**

```java
public class BankTest {

	public static void main(String[] args) {

		Bank bank = new Bank();

		bank.addCustomer("Jane", "Smith");

		bank.getCustomers(0).setAccount(new Account(2000));

		bank.getCustomers(0).getAccount().withdraw(500);

		double balance = bank.getCustomers(0).getAccount().getBalance();

		System.out.println("客户: " + bank.getCustomers(0).getFirstName() + "的账户余额为：" + balance);

		System.out.println("***************************");
		bank.addCustomer("万里", "杨");

		System.out.println("银行客户的个数为: " + bank.getNumberOfCustomers());

	}
}
```

## 08、 关键字：package、import 的使用

### 8.1、关键字—package

```java
/*
 * 一、package 关键字的使用
 * 1.为了更好的实现项目中类的管理，提供包的概念
 * 2.使用 package 声明类或接口所属的包，声明在源文件的首行
 * 3.包，属于标识符，遵循标识符的命名规则、规范"见名知意"
 * 4.每“.”一次,就代表一层文件目录。
 *
 * 补充:同一个包下，不能命名同名接口或同名类
 *     不同包下，可以命名同名的接口、类。
 *
 */
public class PackageImportTest {

}
```

> **JDK 中主要的包介绍**

```java
1.java.lang----包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能
2.java.net----包含执行与网络相关的操作的类和接口。
3.java.io----包含能提供多种输入/输出功能的类。
4.java.util----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
5.java.text----包含了一些 java 格式化相关的类
6.java.sql----包含了 java 进行 JDBC 数据库编程的相关类/接口
7.java.awt----包含了构成抽象窗口工具集（abstractwindowtoolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。B/S  C/S
```

### 8.2、MVC 设计模式

MVC 是常用的设计模式之一，将整个程序分为三个层次：**视图模型层，控制器层，数据模型层**。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/9f9ff69148f88dede9093114379f7173.png)
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/4e1a5995c0b08f5fe36fb09d25e53b61.png)

### 8.3、关键字—import

```java
import java.util.*;

import account2.Bank;

/*
 * 二、import关键字的使用
 * import:导入
 * 1.在源文件中显式的使用import结构导入指定包下的类、接口
 * 2.声明在包的声明和类的声明之间
 * 3.如果需要导入多个结构，则并列写出即可
 * 4.可以使用"xxx.*"的方式,表示可以导入xxx包下的所有结构。
 * 5.如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。
 * 6.如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。
 * 7.如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。
 * 8.import static组合的使用：调用指定类或接口下的静态的属性或方法.
 *
 */
public class PackageImportTest {

	public static void main(String[] args) {
		String info = Arrays.toString(new int[]{1,2,3});

		Bank bank = new Bank();

		ArrayList list = new ArrayList();
		HashMap map = new HashMap();

		Scanner s = null;

		System.out.println("hello");

		UserTest us = new UserTest();

	}
}
```

## 09、继承性的使用与理解

> 1、Person 类

```java
/*
 * 为描述和处理个人信息，定义类 Person
 */
public class Person {

	String name;
	private int age;

	public Person(){

	}

	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}

	public void eat(){
		System.out.println("吃饭");
		sleep();
	}

	private void sleep(){
		System.out.println("睡觉");
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

}
```

> 2、Student 类

```java
/*
 * 为描述和处理学生信息，定义类 Student
 */
public class Student extends Person {

//	String name;
//	int age;
	String major;

	public Student(){

	}

	public Student(String name,int age,String major){
		this.name = name;
//		this.age = age;
		setAge(age);
		this.major = major;
	}

//	public void eat(){
//		System.out.println("吃饭");
//	}
//
//	public void sleep(){
//		System.out.println("睡觉");
//	}

	public void study(){
		System.out.println("学习");
	}

	public void show(){
		System.out.println("name:" + name + ",age = " + getAge());
	}

}
```

> 3、测试类

```java
/*
 * 面向对象的特征二:继承性
 *
 * 为什么要有继承？
 * 		多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，
 * 		那么多个类无需再定义这些属性和行为，只要继承那个类即可。
 *  * 一、继承性的好处
 * ① 减少了代码的冗余，提高了代码的复用性；
 * ② 便于功能的扩展；
 * ③ 为之后多态性的使用，提供了前提。
 *
 * 二、继承性的格式
 * 	class A extends B{}
 *  A:子类、派生类、subclass
 *  B:父类、超类、基类、superclass
 *
 *  2.1 体现：一旦子类 A 继承父类以后，子类 A 中就获取了父类 B 中声明的结构：属性、方法
 * 		特别的，父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。
 * 		只有因为封装性的影响，使得子类不能直接调用父类的结构而已。
 *  2.2 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展。
 *  	子类和父类的关系：不同于子集与集合的关系。
 *  	extends:延展、扩展
 *
 */
public class ExtendsTest {

	public static void main(String[] args) {
		Person p1 = new Person();
//		p1.age = 1;
		p1.eat();
		System.out.println("********************");

		Student s1 = new Student();
		s1.eat();
//		s1.sleep();
		s1.name = "Tom";

		s1.setAge(10);
		System.out.println(s1.getAge());

	}
}
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/cb041fed5ec912d35815aa8e72d8ecdf.png)
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/cc9569b92c2b8879b873cd05741fe753.png)

> 3、Java 中关于继承性的规定

```java
/*  三、Java 中关于继承性的规定：
 *  	1.一个类可以被多个类继承
 *  	2.Java 中类的单继承性：一个类只能有一个父类
 *  	3.子父类是相对的概念。
 *  	4.子类直接继承的父类，称为：直接父类。间接继承的父类，称为，间接父类。
 *  	5.子类继承父类后，就获取了直接父类以及所有间接父类中声明的属性和方法。
 *
 * 四、1.如果我们没有显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类
 * 	  2.所有的 java 类(除 java.long.Object 类之外)都直接或间接地继承于 java.lang.Object 类;
 * 	  3.意味着，所有的 java 类具有 java.lang.Object 类声明的功能。
 */
public class ExtendsTest {

	public static void main(String[] args) {
		s1.brease();

		Creature c = new Creature();
		System.out.println(c.toString());

	}
}
```

> 4、将上述 Person 类改为如下

```java
public class Person extends Creature {
    ...
}
```

> 5、Creature 类

```java
public class Creature {

	public void brease(){
		System.out.println("呼吸");
	}
}
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/8db4be3118c475db5598c470284c8dd4.png)

### 1.1、继承性练习

> 1、练习1

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/fddefc1254d3110ff26903251083c36b.png)

```java
/*
 * 定义类Kids继承ManKind，并包括
 * 成员变量int yearsOld；
 * 方法printAge()打印yearsOld的值
 *
 */
public class Kids extends ManKind{

	private int yearsOld;	//年限

	public Kids() {

	}

	public Kids(int yearsOld) {
		this.yearsOld = yearsOld;
	}

	public int getYearsOld() {
		return yearsOld;
	}

	public void setYearsOld(int yearsOld) {
		this.yearsOld = yearsOld;
	}

	public void printAge(){
		System.out.println("I am " + yearsOld);
	}
}
```

ManKind类

```java
/*
 * 定义一个ManKind类，包括
 * 成员变量int sex和int salary；
 * 方法void manOrWoman()：根据sex的值显示“man”(sex==1)或者“woman”(sex==0)；
 * 方法void employeed()：根据salary的值显示“no job”(salary==0)或者“job”(salary!=0)。
 *
 */
public class ManKind {

	private int sex;	//性别
	private int salary;	//薪资

	public ManKind() {

	}

	public ManKind(int sex, int salary) {
		this.sex = sex;
		this.salary = salary;
	}

	public void manOrWoman(){
		if(sex==1){
			System.out.println("man");
		}else if(sex==0){
			System.out.println("woman");
		}
	}

	public void employeed(){
		if(salary==0){
			System.out.println("no job");
		}else if(salary!=0){
			System.out.println("job");
		}
	}

	public int getSex() {
		return sex;
	}

	public void setSex(int sex) {
		this.sex = sex;
	}

	public int getSalary() {
		return salary;
	}

	public void setSalary(int salary) {
		this.salary = salary;
	}

}
```

KidsTest

```java
/*
 * 定义类KidsTest，在类的main方法中实例化Kids的对象someKid，
 * 用该对象访问其父类的成员变量及方法。
 *
 */
public class KidsTest {
	public static void main(String[] args) {

		Kids someKid = new Kids(12);

		someKid.printAge();

		someKid.setYearsOld(15);
		someKid.setSalary(0);
		someKid.setSex(1);

		someKid.employeed();
		someKid.manOrWoman();
	}
}
```

> 2、练习2

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/c0be1eac6215b7a27e0b209d2fb4dd97.png)

```java
public class Circle {

	public double radius;	//半径

	public Circle(){
		radius = 1.0;
	}

	public double getRadius() {
		return radius;
	}

	public void setRadius(double radius) {
		this.radius = radius;
	}

	public double findArea(){	//计算圆的面积
		return Math.PI * radius * radius;
	}
}
```

Cylinder类

```java
public class Cylinder extends Circle{

	private double length;

	public Cylinder(){
		length = 1.0;
	}

	public double getLength() {
		return length;
	}

	public void setLength(double length) {
		this.length = length;
	}

	public double findVolume(){	//计算圆柱体积
		return findArea() * length;
	}
}
```

测试类

```java
public class CylinderTest {
	public static void main(String[] args) {

		Cylinder cy = new Cylinder();

		cy.setRadius(2.1);
		cy.setLength(3.4);
		double volues = cy.findVolume();
		System.out.println("圆柱的体积:" + volues);

		double area = cy.findArea();
		System.out.println("圆的面积: " + area);
	}
}
```

## 10、方法的重写(override/overwrite)

> 1、Person类

```java
public class Person {

	String name;
	int age;

	public Person(){

	}

	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}

	public void eat(){
		System.out.println("吃饭");
	}

	public void walk(int distance){
		System.out.println("走路，走的距离是：" + distance + "公里");
		show();
	}

	private void show(){
		System.out.println("我是一个人。");
	}

	public Object info(){
		return null;
	}

	public double info1(){
		return 1.0;
	}
}
```

> 2、Student类

```java
public class Student extends Person{

	String major;

	public Student(){

	}

	public Student(String major){
		this.major = major;
	}

	public void study(){
		System.out.println("学习，专业是:" + major);
	}

	//对父类中的eat()进行了重写
	public void eat(){
		System.out.println("学生应该多吃有营养的。");
	}

	public void show(){
		System.out.println("我是一个学生。");
	}

	public String info(){
		return null;
	}

	//不是一个类型，所以报错。
//	public int info1(){
//		return 1;
//	}

	//可以直接将父类的方法的第一行粘过来，直接写方法体
//	public void walk(int distance){
//		System.out.println("重写的方法");
//	}

	//直接输入父类的方法名，Alt + /，选择即可生成
	@Override
	public void walk(int distance) {
		System.out.println("自动生成");
	}
}
```

> 3、测试类

```java
/*
 * 方法的重写(override/overwrite)
 *
 * 1.重写：子类继承父类以后，可以对父类中的方法进行覆盖操作。
 * 2.应用：重写以后，当创建子类对象以后，通过子类对象去调用子父类中同名同参数方法时，执行的是子类重写父类的方法。
 *   即在程序执行时，子类的方法将覆盖父类的方法。
 *
 * 面试题：区分方法的重载与重写(有的书也叫做“覆盖”)
 * 		答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。
 * 		重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。
 * 		如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。
 * 		子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。
 * 		如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。
 *
 */
public class PersonTest {

	public static void main(String[] args) {
		Student s = new Student("计算机科学与技术");
		s.eat();
		s.walk(10);

		s.study();
	}
}
```

### 2.1、方法重写的细节

> 1、Person类

```java
public class Person {

	String name;
	int age;

	public Person(){

	}

	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}

//	public void eat(){
//		System.out.println("吃饭");
//	}
	static void eat(){
		System.out.println("吃饭");
	}

	public void walk(int distance){
		System.out.println("走路，走的距离是：" + distance + "公里");
		show();
	}

	private void show(){
		System.out.println("我是一个人。");
	}

	public Object info(){
		return null;
	}

	public double info1(){
		return 1.0;
	}
}
```

> 2、Student类

```java
public class Student extends Person{

	String major;

	public Student(){

	}

	public Student(String major){
		this.major = major;
	}

	public void study(){
		System.out.println("学习，专业是:" + major);
	}

	//对父类中的eat()进行了重写
//	public void eat(){
//		System.out.println("学生应该多吃有营养的。");
//	}

	//这样不会报错，但已经不是重写了！！
	public static void eat(){
		System.out.println("学生应该多吃有营养的。");
	}

	public void show(){
		System.out.println("我是一个学生。");
	}

	public String info(){
		return null;
	}

	//不是一个类型，所以报错。
//	public int info1(){
//		return 1;
//	}

	//可以直接将父类的方法的第一行粘过来，直接写方法体
//	public void walk(int distance){
//		System.out.println("重写的方法");
//	}

	//直接输入父类的方法名，Alt + /，选择即可生成
	@Override
	public void walk(int distance) {
		System.out.println("自动生成");
	}
}
```

> 3、测试类

```java
/*
 * 3.重写的规定：
 * 		方法的声明：权限修饰符 返回值类型 方法名(形参列表){
 * 						//方法体
 * 				 }
 * 		约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法。
 * 		① 子类重写的方法的方法名和形参列表必须和父类被重写的方法的方法名、形参列表相同;
 * 		② 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限,
 *   		特殊情况: 子类不能重写父类中声明为private权限的方法;
 *   	③ 返回值类型:
 *   		> 父类被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void;
 *   		> 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类;
 *   		> 父类被重写的方法的返回值类型如果是基本数据类型(比如:double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须是:double)。
 *
 *   	④ 子类方法抛出的异常不能大于父类被重写的方法抛出的异常;
 *
 * 注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。
 * 		因为static方法是属于类的，子类无法覆盖父类的方法。
 */
public class PersonTest {

	public static void main(String[] args) {
		Student s = new Student("计算机科学与技术");
		s.eat();
		s.walk(10);
		System.out.println("*******************");

		s.study();

		Person p1 = new Person();
		p1.eat();
	}
}
```

### 2.2、方法的练习

> 1、练习1

```java
1.如果现在父类的一个方法定义成private访问权限，在子类中将此方法声明为default访问权限，那么这样还叫重写吗？(NO)
1
```

> 2、练习2

```java
/*
 * 2.修改练习1.2中定义的类Kids，在Kids中重新定义employeed()方法，
 * 	  覆盖父类ManKind中定义的employeed()方法，
 *   输出“Kids should study and no job.”
 */
public class Kids extends ManKind{

	private int yearsOld;	//年限

	public Kids() {

	}

	public Kids(int yearsOld) {
		this.yearsOld = yearsOld;
	}

	public int getYearsOld() {
		return yearsOld;
	}

	public void setYearsOld(int yearsOld) {
		this.yearsOld = yearsOld;
	}

	public void printAge(){
		System.out.println("I am " + yearsOld);
	}

	public void employeed(){
		System.out.println("Kids should study and no job.");
	}
}
```

MindKids类

```java
public class ManKind {

	private int sex;	//性别
	private int salary;	//薪资

	public ManKind() {

	}

	public ManKind(int sex, int salary) {
		this.sex = sex;
		this.salary = salary;
	}

	public void manOrWoman(){
		if(sex==1){
			System.out.println("man");
		}else if(sex==0){
			System.out.println("woman");
		}
	}

	public void employeed(){
		if(salary==0){
			System.out.println("no job");
		}else if(salary!=0){
			System.out.println("job");
		}
	}

	public int getSex() {
		return sex;
	}

	public void setSex(int sex) {
		this.sex = sex;
	}

	public int getSalary() {
		return salary;
	}

	public void setSalary(int salary) {
		this.salary = salary;
	}

}
```

测试类

```java
public class KidsTest {
	public static void main(String[] args) {

		Kids someKid = new Kids(12);

		someKid.printAge();

		someKid.setYearsOld(15);
		someKid.setSalary(0);
		someKid.setSex(1);

		someKid.employeed();
		someKid.manOrWoman();
	}
}
```

## 11、四种访问权限修饰符

> 四种权限修饰符

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/c10d9f7a2cfc118c122baa567ba968ca.png)

> Order类

```java
package githubb;
/*
 * 体会四种不同的权限修饰符
 */
public class Order {

	private int orderPrivate;
	int orderDefault;
	protected int orderProtected;
	public int orderPublic;

	private void methodPrivate(){
		orderPrivate = 1;
		orderDefault = 2;
		orderProtected = 3;
		orderPublic = 4;
	}

	void methodDefault(){
		orderPrivate = 1;
		orderDefault = 2;
		orderProtected = 3;
		orderPublic = 4;
	}

	protected void methodProtected(){
		orderPrivate = 1;
		orderDefault = 2;
		orderProtected = 3;
		orderPublic = 4;
	}

	public void methodPublic(){
		orderPrivate = 1;
		orderDefault = 2;
		orderProtected = 3;
		orderPublic = 4;
	}
}
```

> Ordertest类

```java
package githubb;

public class OrderTest {
	public static void main(String[] args) {

		Order order = new Order();

		order.orderDefault = 1;
		order.orderProtected = 2;
		order.orderPublic = 3;

		order.methodDefault();
		order.methodProtected();
		order.methodPublic();

		//同一个包中的其它类，不可以调用Order类中私有的属性
//		order.orderPrivate = 4;	//The field Order.orderPrivate is not visible
//		order.methoPrivate();
	}
}
```

> SubOrder类

```java
package githubc;

import githubb.Order;

public class SubOrder extends Order{

	public void method(){
		orderProtected = 1;
		orderPublic = 2;

		methodProtected();
		methodPublic();

		//在不同包的子类中，不能调用Order类中声明为private和缺省的权限的属性、方法
//		orderDefault = 3;
//		orderPrivate = 4;
//
//		methodDefault();
//		methodPrivate();
	}
}
```

> OrderTest类

```java
package githubc;

import githubb.Order;

public class OrderTest {
	public static void main(String[] args) {

		Order order = new Order();
		order.orderPublic = 1;
		order.methodPublic();

		//不同包下的普通类(非子类)要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法。
//		order.orderPrivate = 2;
//		order.orderProtected = 3;
//		order.orderProtected = 4;
//
//		order.methodPrivate();
//		order.methodDefault();
//		order.methodProtected();

	}

	public void show(Order order){
		order.orderPublic = 1;
		order.methodPublic();

		//不同包下的普通类(非子类)要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法。
//		order.orderPrivate = 2;
//		order.orderProtected = 3;
//		order.orderProtected = 4;
//
//		order.methodPrivate();
//		order.methodDefault();
//		order.methodProtected();
	}
}
```

## 12、关键字：super

> Person类

```java
public class Person {

	String name;
	int age;
	int id = 1003;	//身份证号

	public Person(){
		System.out.println("我无处不在");
	}

	public Person(String name){
		this.name = name;
	}

	public Person(String name,int age){
		this(name);
		this.age = age;
	}

	public void eat(){
		System.out.println("人，吃饭");
	}

	public void walk(){
		System.out.println("人，走路");
	}
}
```

> Student类

```java
public class Student extends Person{

	String major;
	int id = 1002;	//学号

	public Student(){

	}

	public Student(String name,int age,String major){
//		this.age = age;
//		this.name = name;
		super(name,age);
		this.major = major;
	}

	public Student(String major){
		this.major = major;
	}

	public void eat(){
		System.out.println("学生多吃有营养的食物");
	}

	public void Study(){
		System.out.println("学生，学习知识。");
		this.eat();
		//如果，想调用父类中被重写的，不想调用子类中的方法，可以：
		super.eat();
		super.walk();//子父类中未重写的方法，用"this."或"super."调用都可以
	}
	public void show(){
		System.out.println("name = " + this.name + ",age = " + super.age);
		System.out.println("id = " + this.id);
		System.out.println("id = " + super.id);
	}
}
```

> 测试类

```java
/*
 * super关键字的使用
 * 1.super理解为:父类的
 * 2.super可以用来调用:属性、方法、构造器
 *
 * 3.super的使用
 * 		3.1 我们可以在子类的方法或构造器中，通过"super.属性"或"super.方法"的方式，显式的调用
 * 	父类中声明的属性或方法。但是，通常情况下，我们习惯去省略这个"super."
 * 		3.2 特殊情况:当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的
 *  使用"super.属性"的方式，表明调用的是父类中声明的属性。
 *  	3.3 特殊情况:当子类重写了父类中的方法后，我们想在子类的方法中调用父类中被重写的方法时，必须显式的
 *  使用"super.方法"的方式，表明调用的是父类中被重写的方法。
 *
 * 4.super调用构造器
 * 	  4.1  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式,调用父类中声明的指定的构造器
 * 	  4.2 "super(形参列表)"的使用，必须声明在子类构造器的首行！
 *    4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现。
 *    4.4 在构造器的首行，既没有显式的声明"this(形参列表)"或"super(形参列表)",则默认的调用的是父类中的空参构造器。super()
 *    4.5 在类的多个构造器中，至少有一个类的构造器使用了"super(形参列表)",调用父类中的构造器。
 *
 */
public class SuperTest {
	public static void main(String[] args) {

		Student s = new Student();
		s.show();

		s.Study();

		Student s1 = new Student("Ton",21,"IT" );
		s1.show();

		System.out.println("***********************");
		Student s2 = new Student();

	}
}
```

## 13、子类对象实例化过程

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/2add7cbc6ccf4e7b02966a050c178675.png)
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/408eeec5cf31085be7d7e0321aa39b3d.png)

```java
/*
 * 子类对象实例化的全过程
 *
 * 1.从结果上看:
 * 		子类继承父类以后，就获取了父类中声明的属性或方法。
 * 		创建子类的对象中，在堆空间中，就会加载所有父类中声明的属性。
 *
 * 2.从过程上看:
 * 		当我们通过子类的构造器创建子类对象时,我们一定会直接或间接的调用其父类构造器，
 * 		直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类结构，所以才可以看到内存中有
 * 		父类中的结构，子类对象可以考虑进行调用。
 *
 * 明确:虽然创建子类对象时，调用了父类的构造器，但自始至终就创建过一个对象，即为new的子类对象。
 */
public class InstanceTest {

}
```

> 练习

Account类

```java
/*
 * 写一个名为Account的类模拟账户。该类的属性和方法如下图所示。
 * 该类包括的属性：账号id，余额balance，年利率annualInterestRate；
 * 包含的方法：访问器方法（getter和setter方法），
 * 返回月利率的方法getMonthlyInterest()，
 * 取款方法withdraw()，存款方法deposit()。
 *
 */
public class Account {

	private int id;	//账号
	private double balance;	//余额
	private double annualInterestRate;	//年利率

	public Account(int id, double balance, double annualInterestRate) {
		super();
		this.id = id;
		this.balance = balance;
		this.annualInterestRate = annualInterestRate;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public double getBalance() {
		return balance;
	}

	public void setBalance(double balance) {
		this.balance = balance;
	}

	public double getAnnualInterestRate() {
		return annualInterestRate;
	}

	public void setAnnualInterestRate(double annualInterestRate) {
		this.annualInterestRate = annualInterestRate;
	}

	public double getMonthlyInterest(){	//返回月利率的方法
		return annualInterestRate / 12;
	}

	public void withdraw (double amount){	//取款方法
		if(balance >= amount){
			balance -= amount;
			return;
		}
		System.out.println("余额不足");
	}

	public void deposit (double amount){	//存款方法
		if(amount > 0){
			balance += amount;

		}
	}

}
```

AccountTest类

```java
/*
 * 写一个用户程序测试Account类。在用户程序中，
 * 创建一个账号为1122、余额为20000、年利率4.5%的Account对象。
 * 使用withdraw方法提款30000元，并打印余额。再使用withdraw方法提款2500元，
 * 使用deposit方法存款3000元，然后打印余额和月利率。
 */
public class AccountTest {
	public static void main(String[] args) {
		Account acct = new Account(1122,20000,0.045);

		acct.withdraw(30000);
		System.out.println("你的账户余额为:" + acct.getBalance());
		acct.withdraw(2500);
		System.out.println("你的账户余额为:" + acct.getBalance());
		acct.deposit(3000);
		System.out.println("你的账户余额为:" + acct.getBalance());

		System.out.println("月利率为: " + (acct.getAnnualInterestRate() * 100) + "%");
	}
}
```

CheckAccount类

```java
/*
 * 创建Account类的一个子类CheckAccount代表可透支的账户，该账户中定义一个属性overdraft代表可透支限额。
 * 在CheckAccount类中重写withdraw方法，其算法如下：
 * 如果（取款金额<账户余额），
 * 可直接取款
 * 如果（取款金额>账户余额），
 * 计算需要透支的额度
 * 判断可透支额overdraft是否足够支付本次透支需要，如果可以
 * 		将账户余额修改为0，冲减可透支金额
 * 如果不可以
 * 		提示用户超过可透支额的限额
 *
 */
public class CheckAccount extends Account{

	private double overdraft;	//代表可透支限额

	public CheckAccount(int id, double balance, double annualInterestRate,double overdraft){
		super(id, balance, annualInterestRate);
		this.overdraft = overdraft;
	}

	public double getOverdraft() {
		return overdraft;
	}

	public void setOverdraft(double overdraft) {
		this.overdraft = overdraft;
	}

	@Override
	public void withdraw(double amount) {
		if(getBalance() >= amount){	//余额足够消费
			//方式一
//			setBalance(getBalance() - amount);
			//方式二
			super.withdraw(amount);
		}else if(overdraft >= amount - getBalance()){	//余额不够

			overdraft -= (amount - getBalance());
//			setBalance(0);
			//或
			super.withdraw(getBalance());

		}else{	//超过可透支限额
			System.out.println("超过可透支限额！");
		}

	}
}
```

CheckAccountTest类

```java
/*
 * 写一个用户程序测试CheckAccount类。在用户程序中，
 * 创建一个账号为1122、余额为20000、年利率4.5%，
 * 可透支限额为5000元的CheckAccount对象。
 * 使用withdraw方法提款5000元，并打印账户余额和可透支额。
 * 再使用withdraw方法提款18000元，并打印账户余额和可透支额。
 * 再使用withdraw方法提款3000元，并打印账户余额和可透支额。
 *
 */
public class CheckAccountTest {
	public static void main(String[] args) {
		CheckAccount cat = new CheckAccount(1122,20000,0.045,5000);

		cat.withdraw(5000);
		System.out.println("您的账户余额为: " + cat.getBalance());
		System.out.println("您的可透支额度为: " + cat.getOverdraft());

		cat.withdraw(18000);
		System.out.println("您的账户余额为: " + cat.getBalance());
		System.out.println("您的可透支额度为: " + cat.getOverdraft());

		cat.withdraw(3000);
		System.out.println("您的账户余额为: " + cat.getBalance());
		System.out.println("您的可透支额度为: " + cat.getOverdraft());
	}
}
```

## 14、面向对象特征之三：多态性

> Person类

```java
public class Person {
	String name;
	int age;

	public void eat(){
		System.out.println("人，吃饭");
	}

	public void walk(){
		System.out.println("人，走路");
	}

}
```

> Woman类

```java
public class Woman extends Person{

	boolean isBeauty;

	public void goShopping(){
		System.out.println("女人喜欢购物");
	}

	public void eat(){
		System.out.println("女人少吃，为了减肥。");
	}

	public void walk(){
		System.out.println("女人，窈窕的走路。");
	}
}
```

> Man类

```java
public class Man extends Person{

	boolean isSmoking;

	public void earnMoney(){
		System.out.println("男人负责工作养家");
	}

	public void eat() {
		System.out.println("男人多吃肉，长肌肉");
	}

	public void walk() {
		System.out.println("男人霸气的走路");
	}
}
```

> 测试类

```java
/*
 * 面向对象之三:多态性
 *
 * 1.理解多态性:可以理解为一个事物的多种态性。
 * 2.何为多态性:
 * 	 对象的多态性:父类的引用指向子类的对象(或子类的对象赋值给父类的引用)
 *
 * 3.多态的使用：虚拟方法调用
 * 	有了对象多态性以后，我们在编译期，只能调用父类声明的方法，但在执行期实际执行的是子类重写父类的方法
 * 			简称：编译时，看左边；运行时，看右边。
 *
 *  若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
 *  多态情况下，
 *  	“看左边”：看的是父类的引用（父类中不具备子类特有的方法）
 *  	“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）
 *
 *  4.多态性的使用前提：
 *  	① 类的继承关系
 *  	② 方法的重写
 *  5.对象的多态性:只适用于方法，不适用于属性(编译和运行都看左边)
 */
public class PersonTest {
	public static void main(String[] args) {

	Person p1 = new Person();
	p1.eat();

	Man man = new Man();
	man.eat();
	man.age = 25;
	man.earnMoney();

	//************************************
	//对象的多态性，父类的引用指向子类的对象
	Person p2 = new Man();
//	Person p3 = new Woman();

	//多态的使用:当调用子父类同名同参数方法时，实际调用的是子类重写父类的方法---虚拟方法调用
	p2.eat();
	p2.walk();

//	p2.earnMoney();

	}
}
```

> 举例

```java
/*
 * 多态性应用举例
 */
public class AnimalTest {

	public static void main(String[] args) {
		AnimalTest test = new AnimalTest();
		test.func(new Dog());

		test.func(new Cat());
	}

	public void func(Animal animal){	//Animal animal = new Dog();
		animal.eat();
		animal.shout();
	}

	//如果没有多态性，就会写很多如下的方法，去调用
	public void func(Dog dog){
		dog.eat();
		dog.shout();
	}

	public void func(Cat cat){
		cat.eat();
		cat.shout();
	}
}

class Animal{

	public void eat(){
		System.out.println("动物，进食");
	}

	public void shout(){
		System.out.println("动物：叫");
	}
}

class Dog extends Animal{
	public void eat(){
		System.out.println("狗吃骨头");
	}

	public void shout() {
		System.out.println("汪！汪！汪！");
	}
}

class Cat extends Animal{
	public void eat(){
		System.out.println("猫吃鱼");
	}

	public void shout() {
		System.out.println("喵！喵！喵！");
	}
}
```

### 6.1、虚拟方法的补充

```java
import java.util.Random;
/*
 * 2.从编译和运行的角度看：
 * 重载，是指允许存在多个同名方法，而这些方法的参数不同。
 * 编译器根据方法不同的参数表，对同名方法的名称做修饰。
 * 对于编译器而言，这些同名方法就成了不同的方法。
 * 它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，
 * 即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，
 * 编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
 * 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，
 * 这称为“晚绑定”或“动态绑定”。
 *
 * 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”
 */
//面试题：多态是编译时行为还是运行时行为？
//证明如下：
class Animal  {

	protected void eat() {
		System.out.println("animal eat food");
	}
}

class Cat  extends Animal  {

	protected void eat() {
		System.out.println("cat eat fish");
	}
}

class Dog  extends Animal  {

	public void eat() {
		System.out.println("Dog eat bone");

	}

}

class Sheep  extends Animal  {

	public void eat() {
		System.out.println("Sheep eat grass");

	}

}

public class InterviewTest {

	public static Animal  getInstance(int key) {
		switch (key) {
		case 0:
			return new Cat ();
		case 1:
			return new Dog ();
		default:
			return new Sheep ();
		}

	}

	public static void main(String[] args) {
		int key = new Random().nextInt(3);

		System.out.println(key);

		Animal  animal = getInstance(key);

		animal.eat();

	}

}
```

### 6.2、向下转型的使用

> Person 类

```java
public class Person {
	String name;
	int age;

	public void eat(){
		System.out.println("人，吃饭");
	}

	public void walk(){
		System.out.println("人，走路");
	}

}
```

> Man 类

```java
public class Man extends Person{

	boolean isSmoking;

	public void earnMoney(){
		System.out.println("男人负责工作养家");
	}

	public void eat() {
		System.out.println("男人多吃肉，长肌肉");
	}

	public void walk() {
		System.out.println("男人霸气的走路");
	}
}
```

> Woman 类

```java
public class Woman extends Person{

	boolean isBeauty;

	public void goShopping(){
		System.out.println("女人喜欢购物");
	}

	public void eat(){
		System.out.println("女人少吃，为了减肥。");
	}

	public void walk(){
		System.out.println("女人，窈窕的走路。");
	}
}
```

> PersonTest 类

```java
/*
 * 面向对象之三:多态性
 *
 * 1.理解多态性:可以理解为一个事物的多种态性。
 * 2.何为多态性:
 * 	 对象的多态性:父类的引用指向子类的对象(或子类的对象赋值给父类的引用)
 *
 * 3.多态的使用：虚拟方法调用
 * 	有了对象多态性以后，我们在编译期，只能调用父类声明的方法，但在执行期实际执行的是子类重写父类的方法
 * 			简称：编译时，看左边；运行时，看右边。
 *
 *  若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
 *  多态情况下，
 *  	“看左边”：看的是父类的引用（父类中不具备子类特有的方法）
 *  	“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）
 *
 *  4.多态性的使用前提：
 *  	① 类的继承关系
 *  	② 方法的重写
 *  5.对象的多态性:只适用于方法，不适用于属性(编译和运行都看左边)
 */
public class PersonTest {
	public static void main(String[] args) {

		Person p1 = new Person();
		p1.eat();

		Man man = new Man();
		man.eat();
		man.age = 25;
		man.earnMoney();

		// ************************************
		System.out.println("************************");
		// 对象的多态性，父类的引用指向子类的对象
		Person p2 = new Man();
		// Person p3 = new Woman();

		// 多态的使用:当调用子父类同名同参数方法时，实际调用的是子类重写父类的方法---虚拟方法调用
		p2.eat();
		p2.walk();

		// p2.earnMoney();

		System.out.println("**************************");
		// 不能调用子类所特有的方法、属性，编译时，p2是Person类型，

		// p2.earnMoney();

		p2.name = "Tom";
		// p2.isSmoking = true;
		// 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致
		// 编译时，只能调用父类中声明的属性和方法。子类的属性和方法不能调用。

		// 如何才能调用子类所特有的属性和方法？
		// 使用强制类型转换符，也可称为:向下转型
		Man m1 = (Man) p2;
		m1.earnMoney();
		m1.isSmoking = true;

		// 使用强转时，可能出现ClassCastException异常
		// Woman w1 = (Woman)p2;
		// w1.goShopping();

		/*
		 * instanceof关键字的使用
		 *
		 * a instanceof A:判断对象a是否是类A的实例。如果，返回true，如果不是，返回false;
		 *
		 * 使用情境:为了避免在向下转型时出现ClassCastException异常，我们在进行向下转型之前，先进行
		 * instanceof的判断,一旦返回true,就进行向下转型。如果返回false，不进行向下转型。
		 *
		 * 如果a instanceof A返回true,则a instanceof B也返回true。 其中类B是类A的父类。
		 *
		 */

		if (p2 instanceof Woman) {
			Woman w1 = (Woman) p2;
			w1.goShopping();
			System.out.println("**********Woman*********");
		}

		if (p2 instanceof Man) {
			Man m2 = (Man) p2;
			m2.earnMoney();
			System.out.println("*********Man************");
		}

		if (p2 instanceof Person) {
			System.out.println("***********Person************");
		}

		if (p2 instanceof Object) {
			System.out.println("***********object************");
		}

		//向下转型的常见问题
		//练习
		//问题1:编译时通过，运行时不通过
		//举例一
//		Person p3 = new Woman();
//		Man m3 = (Man)p3;

		//举例二
		Person p4 = new Person();
		Man m4 = (Man)p4;

		//问题二:编译通过，运行时也通过
		Object obj = new Woman();
		Person p = (Person)obj;

		//问题三:编译不通过
//		Man m5 = new woman();

//		String str = new Date();

//		Object o = new Date();
//		String str1 = (String)o;
	}
}
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/c6dcce377d1fae98ba497cc11d3b4163.png)

### 6.3、多态性的练习

> 1、练习1

```java
/*
 * 练习:子类继承父类
 *
 * 1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，
 * 系统将不可能把父类里的方法转移到子类中。
 *
 * 2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，
 * 这个实例变量依然不可能覆盖父类中定义的实例变量
 *
 */
public class FieldMethodTest {
	public static void main(String[] args){
		Sub s= new Sub();
		System.out.println(s.count);	//20
		s.display();//20

		Base b = s;
		//==:对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否一样。
		System.out.println(b == s);	//true
		System.out.println(b.count);	//10
		b.display();
	}
}

class Base {
	int count= 10;
	public void display() {
		System.out.println(this.count);
	}
}

class Sub extends Base {
	int count= 20;
	public void display() {
		System.out.println(this.count);
	}
}
```

> 2、练习2

```java
/*
 * 建立InstanceTest 类，在类中定义方法method(Person e);
 *
 * 在method中:
 * (1)根据e的类型调用相应类的getInfo()方法。
 * (2)根据e的类型执行：
 * 		如果e为Person类的对象，输出：“a person”;
 * 		如果e为Student类的对象，输出：“a student”“a person ”
 * 		如果e为Graduate类的对象，输出：“a graduated student”
 * 		“a student” “a person”
 *
 */
class Person {
	protected String name = "person";
	protected int age = 50;

	public String getInfo() {
		return "Name: " + name + "\n" + "age: " + age;
	}
}

class Student extends Person {
	protected String school = "pku";

	public String getInfo() {
		return "Name: " + name + "\nage: " + age + "\nschool: " + school;
	}
}

class Graduate extends Student {
	public String major = "IT";

	public String getInfo() {
		return "Name: " + name + "\nage: " + age + "\nschool: " + school + "\nmajor:" + major;
	}
}

public class InstanceTest{

	public static void main(String[] args) {
		//虚拟方法调用
		InstanceTest test = new InstanceTest();
		test.method(new Student());

	}

	public void method(Person e){
		String info = e.getInfo();
		System.out.println(info);

		//方法一
		if(e instanceof Graduate){
			System.out.println("a graduated student");
			System.out.println("a student");
			System.out.println("a person");
		}else if(e instanceof Student){
			System.out.println("a student");
			System.out.println("a person");
		}else{
			System.out.println("a person");
		}

		//方法二
		if(e instanceof Graduate){
			System.out.println("a graduated student");
		}
		if(e instanceof Student){
			System.out.println("a student");
		}
		if(e instanceof Person){
			System.out.println("a person");
		}
	}
}
```

> 3、练习3

GeometricObject类

```java
/*
 * 定义三个类，父类GeometricObject代表几何形状，子类Circle代表圆形，MyRectangle代表矩形。
 */
public class GeometricObject {
	protected String color;
	protected double weight;
	public String getColor() {
		return color;
	}
	public void setColor(String color) {
		this.color = color;
	}
	public double getWeight() {
		return weight;
	}
	public void setWeight(double weight) {
		this.weight = weight;
	}
	public GeometricObject(String color, double weight) {
		super();
		this.color = color;
		this.weight = weight;
	}

	public double findArea(){
		return 0.0;
	}
}
```

Circle类

```java
public class Circle extends GeometricObject {

	private double radius;

	public Circle(double weight,String color, double radius) {
		super(color,weight);
		this.radius = radius;
	}

	public double getRadius() {
		return radius;
	}

	public void setRadius(double radius) {
		this.radius = radius;
	}

	@Override
	public double findArea() {
		return 3.14 * radius * radius;
	}
}
```

MyRectangle类

```java
public class MyRectangle extends GeometricObject {

	private double width;
	private double height;

	public MyRectangle(double width, double height,String color,double weight) {
		super(color, weight);
		this.height = height;
		this.width = width;
	}

	public double getWidth() {
		return width;
	}

	public void setWidth(double width) {
		this.width = width;
	}

	public double getHeight() {
		return height;
	}

	public void setHeight(double height) {
		this.height = height;
	}

	@Override
	public double findArea() {
		return width * height;
	}
}
```

GeometricTest类

```java
/*
 * 定义一个测试类GeometricTest，编写equalsArea方法测试两个对象的面积是否相等（注意方法的参数类型，利用动态绑定技术），
 * 编写displayGeometricObject方法显示对象的面积（注意方法的参数类型，利用动态绑定技术）。
 *
 */
public class GeometricTest {

	public static void main(String[] args) {
		GeometricTest test = new GeometricTest();

		Circle c1 = new Circle(2.3,"white",1.0);
		test.displayGeometricObject(c1);

		Circle c2 = new Circle(3.3,"white",1.0);
		test.displayGeometricObject(c2);

		boolean isEqual = test.equalsArea(c1, c2);
		System.out.println("面积是否相等: " + isEqual);

		MyRectangle rect = new MyRectangle(2.1, 3.4,"red",1.0);
		test.displayGeometricObject(rect);
	}

	public void displayGeometricObject(GeometricObject o){
		System.out.println("面积为: " + o.findArea());
	}

	//测试两个对象的面积是否相等
	public boolean equalsArea(GeometricObject o1,GeometricObject o2){
		return o1.findArea() == o2.findArea();
	}
}
```

练习4

```java
/*
 * 面试题：多态是编译时行为还是运行时行为？如何证明？
 *
 * 证明见如下：
 */
import java.util.Random;

class Animal  {

	protected void eat() {
		System.out.println("animal eat food");
	}
}

class Cat  extends Animal  {

	protected void eat() {
		System.out.println("cat eat fish");
	}
}

class Dog  extends Animal  {

	public void eat() {
		System.out.println("Dog eat bone");
	}
}

class Sheep  extends Animal  {

	public void eat() {
		System.out.println("Sheep eat grass");

	}

}

public class InterviewTest {

	public static Animal  getInstance(int key) {
		switch (key) {
		case 0:
			return new Cat ();
		case 1:
			return new Dog ();
		default:
			return new Sheep ();
		}

	}

	public static void main(String[] args) {
		int key = new Random().nextInt(3);

		System.out.println(key);

		Animal  animal = getInstance(key);

		animal.eat();

	}
}
```

> 4、面试题拓展

```java
/* 考查多态的笔试题目：
 * 面试题：多态是编译时行为还是运行时行为？如何证明？
 *
 * 拓展问题
 */
public class InterviewTest1 {

	public static void main(String[] args) {
		Base base = new Sub();
		base.add(1, 2, 3);

//		Sub s = (Sub)base;
//		s.add(1,2,3);
	}
}

class Base {
	public void add(int a, int... arr) {
		System.out.println("base");
	}
}

class Sub extends Base {

	public void add(int a, int[] arr) {
		System.out.println("sub_1");
	}

//	public void add(int a, int b, int c) {
//		System.out.println("sub_2");
//	}

}
```

## 15、Object 类的使用

```java
/*
 * java.lang.Object类
 * 1.Object类是所有Java类的根父类;
 * 2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
 * 3.Object类中的功能(属性、方法)就具有通用性。
 * 属性:无
 * 方法:equals() / toString() / getClass() / hashCode() / clone() /finalize()
 * 	 wait() 、notify()、notifyAll()
 *
 * 4.Object类只声明了一个空参的构造器。
 *
 * 面试题:
 * final、finally、finalize的区别？
 *
 */
public class ObjectTest {

	public static void main(String[] args) {

	}
}

class Order{

}
```

### 7.1、Object类中的主要结构

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/d9de1281feb25f434a69f809adeb4a24.png)

### 7.2、==操作符与equals方法

```java
import java.sql.Date;

/*
 * 面试题: ==和equals的区别
 *
 * 一、回顾==的使用
 * == : 运算符
 * 1.可以使用在基本数据类型变量和引用数据类型变量中
 * 2.如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。(不一定类型要相同)
 * 	   如果比较的是引用数据类型变量：比较两个对象的地址值是否相同,即两个引用是否指向同一个对象实体
 *  补充: == 符号使用时，必须保证符号左右两边的变量类型一致。
 *
 * 二、equals()方法的使用
 * 1.是一个方法，而非运算符
 * 2.只能适用于引用数据类型。
 * 3.Object类中equals()的定义：
 * 		public boolean equals(Object obj){
 * 			return (this == obj);
 * 		}
 * 说明：Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。
 *
 * 4.像String、Date、File、包装类等都重写了Object类中的equals()方法.
 * 	 两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。
 *
 * 5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们
 * 	   就需要对Object类中的equals()进行重写。
 *
 * 重写的原则:比较两个对象的实体内容是否相同。
 *
 */
public class EqualsTest {
	public static void main(String[] args) {

		//基本数据类型
		int i = 10;
		int j = 10;
		double d = 10.0;
		System.out.println(i == j);	//true
		System.out.println(i == d); //true

//		boolean b =true;
//		System.out.println(i == b);

		char c = 10;
		System.out.println(i == c); //true

		char c1 = 'A';
		char c2 = 65;
		System.out.println(c1 == c2); //true

		//引用数据类型
		Customer cust1 = new Customer("Tom" ,21);
		Customer cust2 = new Customer("Tom" ,21);
		System.out.println(cust1 == cust2); //false

		String str1 = new String("BAT");
		String str2 = new String("BAT");
		System.out.println(str1 == str2); //false
		System.out.println("*************************");
		System.out.println(cust1.equals(cust2));	//false
		System.out.println(str1.equals(str2));	//true

		Date date1 = new Date(23432525324L);
		Date date2 = new Date(23432525324L);
		System.out.println(date1.equals(date2));	//true
	}
}
```

> Customer类

```java
public class Customer {

	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public Customer() {
		super();
	}
	public Customer(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	//自动生成的equals()
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Customer other = (Customer) obj;
		if (age != other.age)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	//重写原则，比较两个对象的实体内容(即name和age)是否相同
	//手动实现equals()的重写
//	@Override
//	public boolean equals(Object obj) {
//
		System.out.println("Customer equals()....");
//		if(this == obj){
//			return true;
//		}
//
//		if(obj instanceof Customer){
//			Customer cust = (Customer)obj;
//			//比较两个对象的属性是否都相同
			if(this.age == cust.age && this.name.equals(cust.name)){
				return true;
			}else{
				return false;
			}
//
//			//或
//			return this.age == cust.age && this.name.equals(cust.name);
//		}
//
//		return false;
//	}

}
```

#### 7.2.1、重写equals()方法的原则

*   对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。
*   自反性：x.equals(x)必须返回是“true”。
*   传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。
*   一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。
*   任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。

```java
	int it = 65;
    float fl= 65.0f;
	System.out.println("65和65.0f是否相等？" + (it == fl)); //true
	char ch1 = 'A';
	char ch2 = 12;
	System.out.println("65和'A'是否相等？" + (it == ch1));//true
	System.out.println("12和ch2是否相等？" + (12 == ch2));//true
	String str1 = new String("hello");
	String str2 = new String("hello");
	System.out.println("str1和str2是否相等？"+ (str1 == str2));//false
	System.out.println("str1是否equals str2？"+(str1.equals(str2)));//true
	System.out.println("hello" == new java.util.Date()); //编译不通过
```

> 练习一

```java
/*
 * .编写Order类，有int型的orderId，String型的orderName，
 * 相应的getter()和setter()方法，两个参数的构造器，重写父类的equals()方法：public booleanequals(Object obj)，
 * 并判断测试类中创建的两个对象是否相等。
 *
 *
 */
public class OrderTest {
	public static void main(String[] args) {
		Order order1 = new Order(1001,"AA");
		Order order2 = new Order(1001,"BB");

		System.out.println(order1.equals(order2));	//false

		Order order3 = new Order(1001,"BB");
		System.out.println(order2.equals(order3)); //true
	}
}

class Order{
	private int orderId;
	private String orderName;
	public int getOrderId() {
		return orderId;
	}
	public void setOrderId(int orderId) {
		this.orderId = orderId;
	}
	public String getOrderName() {
		return orderName;
	}
	public void setOrderName(String orderName) {
		this.orderName = orderName;
	}
	public Order(int orderId, String orderName) {
		super();
		this.orderId = orderId;
		this.orderName = orderName;
	}
	public boolean equals(Object obj){
		if(this == obj){
			return true;
		}
		if(obj instanceof Order){
			Order order = (Order)obj;
			//正确的
			return this.orderId == order.orderId && this.orderName.equals(order.orderName);
			//错误的
//			return this.orderId == order.orderId && this.orderName == order.orderName;
		}
		return false;
	}
}
```

> 练习二

```java
/*
 * 请根据以下代码自行定义能满足需要的MyDate类,在MyDate类中覆盖equals方法，
 * 使其判断当两个MyDate类型对象的年月日都相同时，结果为true，否则为false。
 * public boolean equals(Object o)
 */
public class MyDateTest {
	public static void main(String[] args) {
		MyDate m1= new MyDate(14, 3, 1976);
		MyDate m2= new MyDate(14, 3, 1976);
		if(m1== m2) {
			System.out.println("m1==m2");
		} else{
			System.out.println("m1!=m2"); // m1 != m2
		}

		if(m1.equals(m2)) {
			System.out.println("m1 is equal to m2");// m1 is equal to m2
		} else{
			System.out.println("m1 is not equal to m2");
		}
	}
}

class MyDate{
	private int day;
	private int month;
	private int year;

	public MyDate(int day, int month, int year) {
		super();
		this.day = day;
		this.month = month;
		this.year = year;
	}

	public int getDay() {
		return day;
	}

	public void setDay(int day) {
		this.day = day;
	}

	public int getMonth() {
		return month;
	}

	public void setMonth(int month) {
		this.month = month;
	}

	public int getYear() {
		return year;
	}

	public void setYear(int year) {
		this.year = year;
	}

	@Override
	public boolean equals(Object obj) {
		if(this == obj){
			return true;
		}
		if(obj instanceof MyDate){
			MyDate myDate = (MyDate)obj;
			return this.day == myDate.day && this.month == myDate.month &&
					this.year == myDate.year;
		}
		return false;
	}

//	@Override
//	public boolean equals(Object obj) {
//		if (this == obj)
//			return true;
//		if (obj == null)
//			return false;
//		if (getClass() != obj.getClass())
//			return false;
//		MyDate other = (MyDate) obj;
//		if (day != other.day)
//			return false;
//		if (month != other.month)
//			return false;
//		if (year != other.year)
//			return false;
//		return true;
//	}

}
```

### 7.3、toString的使用

```java
public class Customer {

	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public Customer() {
		super();
	}
	public Customer(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	//自动生成的equals()
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Customer other = (Customer) obj;
		if (age != other.age)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}

	//重写原则，比较两个对象的实体内容(即name和age)是否相同
	//手动实现equals()的重写
//	@Override
//	public boolean equals(Object obj) {
//
		System.out.println("Customer equals()....");
//		if(this == obj){
//			return true;
//		}
//
//		if(obj instanceof Customer){
//			Customer cust = (Customer)obj;
//			//比较两个对象的属性是否都相同
			if(this.age == cust.age && this.name.equals(cust.name)){
				return true;
			}else{
				return false;
			}
//
//			//或
//			return this.age == cust.age && this.name.equals(cust.name);
//		}
//
//		return false;
//	}

	//手动实现
//	@Override
//	public String toString() {
//		return "Customer[name = " + name + ",age = " + age + "]";
//	}

	//自动实现
	@Override
	public String toString() {
		return "Customer [name=" + name + ", age=" + age + "]";
	}

}
```

> ToStringTest类

```java
import java.util.Date;
/*
 * Object类中toString()的使用
 *
 * 1.当我们输出一个引用对象时，实际上就是调用当前对象的toString()
 * 2.Object类中toString的定义方法
 * 	public String toString() {
 *      return getClass().getName() + "@" + Integer.toHexString(hashCode());
 *  }
 *
 * 3.像String、Date、File、包装类等都重写了Object类中的toString()方法。
 * 	 使得在调用toString()时，返回"实体内容"信息.
 *
 * 4.自定义类如果重写toString()方法，当调用此方法时，返回对象的"实体内容".
 */
public class ToStringTest {
	public static void main(String[] args) {

		Customer cust1 = new Customer("Tom" ,21);
		System.out.println(cust1.toString());	//github4.Customer@15db9742
		System.out.println(cust1); 	//github4.Customer@15db9742 ---> Customer[name = Tom,age = 21]

		String str = new String("MM");
		System.out.println(str);

		Date date = new Date(45362348664663L);
		System.out.println(date.toString());	//Wed Jun 24 12:24:24 CST 3407

	}
}
```

> 练习

GeometricObject类

```java
public class GeometricObject {
	protected  String  color;
	protected  double  weight;

	public GeometricObject() {
		super();
		this.color = "white";
		this.weight = 1.0;
	}

	public GeometricObject(String color, double weight) {
		super();
		this.color = color;
		this.weight = weight;
	}

	public String getColor() {
		return color;
	}

	public void setColor(String color) {
		this.color = color;
	}

	public double getWeight() {
		return weight;
	}

	public void setWeight(double weight) {
		this.weight = weight;
	}
}
```

> Circle类

```java
public class Circle extends GeometricObject{
	private double radius;

	public Circle() {	//初始化对象的color属性为“white”，weight属性为1.0，radius属性为1.0。
		super();	//super自带，不需再写
//		this.color = "white";
//		this.weight = 1.0;
		this.radius = 1.0;
	}

	//初始化对象的color属性为“white”，weight属性为1.0，radius根据参数构造器确定。
	public Circle(double radius) {
		super();	//super自带，不需再写
//		this.color = "white";
//		this.weight = 1.0;
		this.radius = radius;
	}

	public Circle(double radius,String color,double weight) {
		super(color,weight);
		this.radius = radius;
	}

	public double getRadius() {
		return radius;
	}

	public void setRadius(double radius) {
		this.radius = radius;
	}

	//计算圆的面积
	public double findArea(){
		return Math.PI * radius * radius;
	}

	@Override	//重写equals方法,比较两个圆的半径是否相等，如相等，返回true。
	public boolean equals(Object obj) {
		if(this == obj){
			return true;
		}

		if(obj instanceof Circle){
			Circle c = (Circle)obj;
			return this.radius == c.radius;
		}

		return false;
	}

	@Override
	public String toString() {	//重写toString方法,输出圆的半径。
		return "Circle [radius=" + radius + "]";
	}

}
```

> 测试类

```java
/*
 * 写一个测试类，创建两个Circle对象，判断其颜色是否相等；
 * 利用equals方法判断其半径是否相等；利用toString()方法输出其半径。
 *
 */
public class CircleTest {
	public static void main(String[] args) {

		Circle circle1 = new Circle(2.3);
		Circle circle2 = new Circle(3.3,"white",2.0);

		System.out.println("颜色是否相等: " + circle1.getColor().equals(circle2.color));

		System.out.println("半径是否相等: " + circle1.equals(circle2));

		System.out.println(circle1);
		System.out.println(circle2.toString());
	}
}
```

## 16、包装类(Wrapper)的使用

### 8.1、单元测试方法的使用

```java
import java.util.Date;
import org.junit.Test;
/*
 * java中的JUnit单元测试
 *
 * 步骤:
 * 1.选中当前项目工程 --》 右键:build path --》 add libraries --》 JUnit 4 --》 下一步
 * 2.创建一个Java类进行单元测试。
 * 	 此时的Java类要求:①此类是公共的 ②此类提供一个公共的无参构造器
 * 3.此类中声明单元测试方法。
 *   此时的单元测试方法:方法的权限是public,没有返回值，没有形参。
 *
 * 4.此单元测试方法上需要声明注解:@Test并在单元测试类中调用:import org.junit.Test;
 * 5.声明好单元测试方法以后，就可以在方法体内测试代码。
 * 6.写好代码后，左键双击单元测试方法名：右键 --》 run as --》 JUnit Test
 *
 * 说明:如果执行结果无错误，则显示是一个绿色进度条，反之，错误即为红色进度条。
 */
public class JUnit {

	int num = 10;

	//第一个单元测试方法
	@Test
	public void testEquals(){
		String s1 = "MM";
		String s2 = "MM";
		System.out.println(s1.equals(s2));

		//ClassCastException的异常
//		Object obj = new String("GG");
//		Date date = (Date)obj;

		System.out.println(num);
		show();
	}

	public void show(){
		num = 20;
		System.out.println("show()...");
	}

	//第二个单元测试方法
	@Test
	public void testToString(){
		String s2 = "MM";
		System.out.println(s2.toString());
	}
}
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/2ed96054861a4fa797a564eee2d09cbb.png)
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/9cacb9d5a49fbe6e8ca4f7831975db7d.png)
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/cef0b809e8ecccc1ad7c7bb7f71d625d.png)

### 8.2、包装类的使用

```java
/*
 * 包装类的使用
 * 1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征
 * 		基本数据类型		包装类
 * 		byte			Byte
 * 		short			Short
 * 		int 			Integer
 * 		long			Long
 * 		float			Float
 * 		double			Double
 * 		boolean			Boolean
 * 		char			Character
 * 注意:其中Byte、Short、Integer、Long、Float、Double的父类是:Number
 * /
```

### 8.3、包装类与基本数据类型相互转换

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/fa0116bbaf03d264cc9650a3319da2a8.png)

```java
import org.junit.Test;
/*
 * 2.基本数据类型、包装类、String三者之间的相互转换。
 *
 */
public class WrapperTest {

	//String类型---> 基本数据类型、包装类,调用包装类的parseXxx()
	@Test
	public void test5(){
		String str1 = "123";
//		String str1 = "123a";

		//错误的情况，可能会报错
//		int num1 = (int)str1;
//		Integer in1 = (Integer)str1;

		int num2 = Integer.parseInt(str1);
		System.out.println(num2 + 1);	//124

		String str2 = "true";
		Boolean b1 = Boolean.parseBoolean(str2);
		System.out.println(b1);	//true

	}

	//基本数据类型、包装类---》String类型，调用String重载的valueOf(Xxx xxx)
	@Test
	public void test4(){
		int num1 = 10;
		//方式1:连接运算
		String str1 = num1 + "";
		//方式2:调用String的valueOf(Xxx xxx)
		float f1 = 12.3f;
		String str2 = String.valueOf(f1); //"12.3"

		Double d1 = new Double(12.4);
		String str3 = String.valueOf(d1);
		System.out.println(str2);
		System.out.println(str3);	//"12.4"

	}

	/*
	 * JDK 5.0 新特性:自动装箱与自动拆箱
	 */
	@Test
	public void test3(){
//		int num1 = 10;
//		//基本数据类型 --》 包装类的对象
//		method(num1);	//Object obj = num1

		//自动装箱:基本数据类型 --》 包装类
		int num2 = 10;
		Integer in1 = num2;//自动装箱

		boolean b1 = true;
		Boolean b2 = b1;//自动装箱

		//自动拆箱：包装类 --》 基本数据类型
		System.out.println(in1.toString());

		int num3 = in1;

	}

	public void method(Object obj){
		System.out.println(obj);
	}

	//包装类 --》 基本数据类型:调用包装类的xxxValue()
	@Test
	public void test2() {
		Integer in1 = new Integer(12);
		int i1 = in1.intValue();
		System.out.println(i1 + 1);

		Float f1 = new Float(12.3f);
		float f2 = f1.floatValue();
		System.out.println(f2 + 1);
	}

	//基本数据类型--》包装类,调用包装类的构造器
	@Test
	public void test1() {
		int num1 = 10;
//		System.out.println(num1.toString());

		Integer in1 = new Integer(num1);
		System.out.println(in1.toString());

		Integer in2 = new Integer("123");
		System.out.println(in2.toString());

		//报异常
//		Integer in3 = new Integer("123abc");
//		System.out.println(in3.toString());

		Float f1 = new Float(12.3f);
		Float f2 = new Float("12.3");
		System.out.println(f1);
		System.out.println(f2);

		Boolean b1 = new Boolean(true);
		Boolean b2 = new Boolean("true");

		Boolean b3 = new Boolean("true123");
		System.out.println(b3); //false

		Order order = new Order();
		System.out.println(order.isMale); //false
		System.out.println(order.isFemale); //null

	}
}

class Order{

	boolean isMale;
	Boolean isFemale;
}
```

### 8.4、练习

> 1、面试题

```java
import org.junit.Test;
/*
 * 如下两个题目输出结果相同吗？各是什么：
 * 		Object o1= true? new Integer(1) : new Double(2.0);
 * 		System.out.println(o1);//
 *
 * 		Object o2;
 * 		if(true)
 * 			o2 = new Integer(1);
 *		else
 *			o2 = new Double(2.0);
 *		System.out.println(o2);//
 *
 */
public class InterViewTest {

	@Test
	public void test(){
		Object o1= true? new Integer(1) : new Double(2.0);
		System.out.println(o1);// 1.0
	}

	@Test
	public void test2(){
		Object o2;
		if(true)
			o2 = new Integer(1);
		else
			o2 = new Double(2.0);
		System.out.println(o2);// 1
	}

	@Test
	public void method1() {
		Integer i = new Integer(1);
		Integer j = new Integer(1);
		System.out.println(i == j); //false

	    //Integer内部定义了一个IntegerCache结构，IntegerCache中定义Integer[]
		//保存了从-128-127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在其中时，
		//可以直接使用数组中的元素，不用再去new了。目的，提高效率。

		Integer m = 1;
		Integer n = 1;
		System.out.println(m == n);//true

		Integer x = 128;//相当于new了一个Integer对象
		Integer y = 128;//相当于new了一个Integer对象
		System.out.println(x == y);//false

	}
}
```

> 2、编程题

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/c80ea8669572b20379dbbd018fadb155.png)

```java
import java.util.Scanner;
import java.util.Vector;

/*
 * 利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），
 * 找出最高分，并输出学生成绩等级。
 *
 * 提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。
 * 而向量类java.util.Vector可以根据需要动态伸缩。
 *
 * 创建Vector对象：Vector v=new Vector();
 * 给向量添加元素：v.addElement(Object obj);   //obj必须是对象
 * 取出向量中的元素：Object  obj=v.elementAt(0);
 * 注意第一个元素的下标是0，返回值是Object类型的。
 * 计算向量的长度：v.size();
 * 若与最高分相差
 * 		10分内：A等；
 * 		20分内：B等；
 * 		30分内：C等；
 * 		其它：D等
 *
 */
public class VectorTest {
	public static void main(String[] args) {
		// 1.实例化Scanner，用于从键盘获取学生成绩
		Scanner scan = new Scanner(System.in);

		// 2.创建Vector对象：Vector v=new Vector();相当于原来的数组
		Vector v = new Vector();

		// 3.通过for(;;)或while(true)方式，给Vector中添加数组
		int maxScore = 0;
		for (;;) {
			System.out.println("请输入学生成绩（以负数代表输入结束）");
			int score = scan.nextInt();
			// 3.2 当输入是负数时，跳出循环
			if (score < 0) {
				break;
			}
			if (score > 100) {
				System.out.println("输入的数据非法，请重新输入");
				continue;
			}
			// 3.1 添加操作：：v.addElement(Object obj)
			// jdk5.0之前：
			// Integer inScore = new Integer(score);
			// v.addElement(inScore);//多态
			// jdk5.0之后：
			v.addElement(score);// 自动装箱
			// 4.获取学生成绩的最大值
			if (maxScore < score) {
				maxScore = score;
			}
		}

		// 5.遍历Vector，得到每个学生的成绩，并与最大成绩比较，得到每个学生的等级。
		char level;
		for (int i = 0; i < v.size(); i++) {
			Object obj = v.elementAt(i);
			// jdk 5.0之前：
			// Integer inScore = (Integer)obj;
			// int score = inScore.intValue();
			// jdk 5.0之后：
			int score = (int) obj;

			if (maxScore - score <= 10) {
				level = 'A';
			} else if (maxScore - score <= 20) {
				level = 'B';
			} else if (maxScore - score <= 30) {
				level = 'C';
			} else {
				level = 'D';
			}

			System.out.println("student-" + i + " score is " + score + ",level is " + level);

		}
	}
}
```

## 17、关键字：static

### 1.1、static 的使用

当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过 new 关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。

我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，**某些特定的数据在内存空间里只有一份。**

例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/2057c0097587294fd28906287961f445.png)

```java
/*
 * static 关键字的使用
 *
 * 1.static:静态的。
 * 2.static 可以用来修饰:属性、方法、代码块、内部类。
 *
 * 3.使用 static 修饰属性:静态变量(或类变量)。
 * 		3.1  属性:是否使用 static 修饰，又分为:静态属性 VS 非静态属性(实例变量)
 * 		   实例变量:我们创建了类的多个对象，每个对象都独立的拥有了一套类中的非静态属性。
 * 				当修改其中一个非静态属性时，不会导致其他对象中同样的属性值的修饰。
 * 		   静态变量:我们创建了类的多个对象，多个对象共享同一个静态变量。当通过静态变量去修改某一个变量时，
 * 				会导致其他对象调用此静态变量时，是修改过的。
 * 		3.2 static 修饰属性的其他说明:
 * 			① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用。
 * 			② 静态变量的加载要早于对象的创建。
 * 			③ 由于类只会加载一次，则静态变量在内存中也只会存在一次。存在方法区的静态域中。
 *
 * 			④ 		类变量		实例变量
 * 			类		yes			no
 * 			对象		yes			yes
 *
 * 		3.3 静态属性举例:System.out.Math.PI;
 *
 */
public class StaticTest {
	public static void main(String[] args) {

		Chinese.nation = "中国";

		Chinese c1 = new Chinese();
		c1.name = "姚明";
		c1.age = 40;
		c1.nation = "CHN";

		Chinese c2 = new Chinese();
		c2.name = "马龙";
		c2.age = 30;
		c2.nation = "CHINA";

		System.out.println(c1.nation);

		//编译不通过
//		Chinese.name = "张继科";

	}
}
//中国人
class Chinese{

	String name;
	int age;
	static String nation;
}
```

### 1.2、类变量 vs 实例变量内存解析

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/97cc52e6668ddb59b0a2fc1d63b99607.png)

### 1.3、static 修饰方法

```java
/*
 * 4.使用 static 修饰方法:静态方法
 * 		① 随着类的加载而加载，可以通过"类.静态方法"的方式调用
 * 		② 			静态方法		非静态方法
 * 			类		yes			no
 * 			对象		yes			yes
 * 		③ 静态方法中，只能调用静态的方法或属性
 * 		  非静态的方法中，可以调用所有的方法或属性
 *
 * 5.static 注意点:
 * 	 5.1  在静态的方法内，不能使用 this 关键字、super 关键字
 *   5.2 关于静态属性和静态方法的使用，大家从生命周期的角度去理解。
 *
 * 6.开发中，如何确定一个属性是否需要声明 static 的？
 * 	 》 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
 * 	 》 类中的常量也常常声明为 static
 *
 *   开发中，如何确定一个方法是否要声明为 static 的？
 *   》 操作静态属性的方法，通常设置为 static 的
 *   》 工具类中的方法，习惯上声明为 static 的。比如：Math、Arrays、Collections
 *
 */
public class StaticTest {
	public static void main(String[] args) {

		Chinese.nation = "中国";

		Chinese c1 = new Chinese();

		//编译不通过
//		Chinese.name = "张继科";

		c1.eat();

		Chinese.show();
		//编译不通过
//		chinese.eat();
//		Chinese.info();
	}
}
//中国人
class Chinese{

	String name;
	int age;
	static String nation;

	public void eat(){
		System.out.println("中国人吃中餐");
		//调用非静态结构
		this.info();
		System.out.println("name : " + name);
		//调用静态结构
		walk();
		System.out.println("nation : " + Chinese.nation);
	}

	public static void show(){
		System.out.println("我是一个中国人！");
//		eat();
//		name = "Tom";
		//可以调用静态的结构
		System.out.println(Chinese.nation);
		walk();
	}

	public void info(){
		System.out.println("name : " + name + ",age : " + age);
	}

	public static void walk(){

	}
}
```

### 1.4、自定义 ArrayUtil 的优化

```java
/*
 * 自定义数组工具类
 */
public class ArrayUtil {

	// 求数组的最大值
	public static int getMax(int[] arr) {
		int maxValue = arr[0];
		for (int i = 1; i < arr.length; i++) {
			if (maxValue < arr[i]) {
				maxValue = arr[i];
			}
		}
		return maxValue;
	}

	// 求数组的最小值
	public static int getMin(int[] arr) {
		int minValue = arr[0];
		for (int i = 1; i < arr.length; i++) {
			if (minValue > arr[i]) {
				minValue = arr[i];
			}
		}
		return minValue;
	}

	// 求数组总和
	public static int getSum(int[] arr) {
		int sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
		}
		return sum;
	}

	// 求数组平均值
	public static int getAvg(int[] arr) {
		int avgValue = getSum(arr) / arr.length;
		return avgValue;
	}

	//如下两个同名方法构成重载
	// 反转数组
	public static void reverse(int[] arr) {
		for (int i = 0; i < arr.length / 2; i++) {
			int temp = arr[i];
			arr[i] = arr[arr.length - i - 1];
			arr[arr.length - i - 1] = temp;
		}
	}

	public void reverse(String[] arr){

	}

	// 复制数组
	public static int[] copy(int[] arr) {
		int[] arr1 = new int[arr.length];
		for (int i = 0; i < arr1.length; i++) {
			arr1[i] = arr[i];
		}
		return null;
	}

	// 数组排序
	public static void sort(int[] arr) {
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 0; j < arr.length - 1 - i; j++) {
				if (arr[j] > arr[j + 1]) {
//					int temp = arr[j];
//					arr[j] = arr[j + 1];
//					arr[j + 1] = temp;
					//错误的：
//					swap(arr[j],arr[j+1]);

					swap(arr,j ,j+1);
				}
			}
		}
	}

	//错误的:交换数组中两个指定位置元素的值
//	public void swap(int i,int j){
//		int temp = i;
//		i = j;
//		j = temp;
//	}

	//正确的：
	private static void swap(int[] arr,int i,int j){
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}

	// 遍历数组
	public static void print(int[] arr) {
		System.out.print("[");
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + ",");
		}
		System.out.println("]");
	}

	// 查找指定元素
	public static int getIndex(int[] arr, int dest) {
		//线性查找
		for (int i = 0; i < arr.length; i++) {

			if (dest==arr[i]) {
				return i;
			}

		}
		return -1;
	}

}
```

> 测试类

```java
public class ArrayUtilTest {

	public static void main(String[] args) {
//		ArrayUtil util = new ArrayUtil();
		int[] arr = new int[]{32,5,26,74,0,96,14,-98,25};
		int max = ArrayUtil.getMax(arr);
		System.out.println("最大值为:" + max);

		System.out.print("排序前:");
		ArrayUtil.print(arr);

		ArrayUtil.sort(arr);
		System.out.print("排序后:");
		ArrayUtil.print(arr);

//		System.out.println("查找:");
//		int index = util.getIndex(arr, 5);
//		if(index > 0){
//			System.out.println("找到了，索引地址:" + index);
//		}else{
//			System.out.println("没找到");
//		}
	}
}
```

### 1.5、static 的应用举例

```java
//static 关键字的应用
public class CircleTest {
	public static void main(String[] args) {

		Circle c1 = new Circle();

		Circle c2 = new Circle();

		Circle c3 = new Circle();

		System.out.println("c1 的 ID:" + c1.getId());
		System.out.println("c2 的 ID:" + c2.getId());
		System.out.println("c3 的 ID:" + c3.getId());

		System.out.println("创建圆的个数: " + Circle.getTotal());

	}

}

class Circle{

	private double radius;
	private int id;	//需要自动赋值

	public Circle(){
		id = init++;
		total++;
	}

	public Circle(double radius){
		this();
		//或
//		id = init++;
//		total++;
		this.radius = radius;
	}

	private static int total;//记录创建圆的个数
	private static int init = 1001;//static 声明的属性被所有对象所共享

	public double findArea(){
		return 3.14 * radius * radius;
	}

	public double getRadius() {
		return radius;
	}

	public void setRadius(double radius) {
		this.radius = radius;
	}

	public int getId() {
		return id;
	}

	public static int getTotal() {
		return total;
	}

}
```

### 1.6、static 的练习

```java
/*
 * 编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、
 * “利率”、“最小余额”，定义封装这些属性的方法。
 * 账号要自动生成。编写主类，使用银行账户类，输入、输出 3 个储户的上述信息。
 * 考虑：哪些属性可以设计成 static 属性。
 *
 */
public class Account {

	private int id;	//账号
	private String pwd = "000000";	//密码
	private double balance; //存款余额

	private static double interestRate; //利率
	private static double minMoney = 1.0;  //最小余额
	private static int init = 1001;	//用于自动生成 id

	public Account(){	//账号自动生成
		id = init++;
	}

	public Account(String pwd,double balance){
		id = init++;
		this.pwd = pwd;
		this.balance = balance;
	}

	public String getPwd() {
		return pwd;
	}

	public void setPwd(String pwd) {
		this.pwd = pwd;
	}

	public static double getInterestRate() {
		return interestRate;
	}

	public static void setInterestRate(double interestRate) {
		Account.interestRate = interestRate;
	}

	public static double getMinMoney() {
		return minMoney;
	}

	public static void setMinMoney(double minMoney) {
		Account.minMoney = minMoney;
	}

	public int getId() {
		return id;
	}

	public double getBalance() {
		return balance;
	}

	@Override
	public String toString() {
		return "Account [id=" + id + ", pwd=" + pwd + ", balance=" + balance + "]";
	}

}
```

> **测试类**

```java
public class AccountTest {
	public static void main(String[] args) {

		Account acct1 = new Account();
		Account acct2 = new Account("qwerty",2000);

		Account.setInterestRate(0.012);
		Account.setMinMoney(100);

		System.out.println(acct1);
		System.out.println(acct2);

		System.out.println(acct1.getInterestRate());
		System.out.println(acct1.getMinMoney());
	}
}
```

### 1.7、单例(Singleton)设计模式

设计模式是\*\*在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。\*\*设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对**某个类只能存在一个对象实例**。并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的**构造器的访问权限设置为 private**，这样，就不能用 new 操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，**只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。**

> 1、**单例模式的饿汉式**

```java
/*
 * 单例设计模式:
 * 1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例
 *
 * 2.如何实现？
 *   饿汉式	VS	懒汉式
 *
 * 3.区分饿汉式和懒汉式。
 * 	   饿汉式：坏处:对象加载时间过长。
 * 	 	       好处:饿汉式是线程安全的。
 *
 *   懒汉式：好处:延迟对象的创建。
 * 		       坏处:目前的写法，会线程不安全。---》到多线程内容时，再修改
 */
public class SingletonTest {
	public static void main(String[] args) {
//		Bank bank1 = new Bank();
//		Bank bank2 = new Bank();

		Bank bank1 = Bank.getInstance();
		Bank bank2 = Bank.getInstance();

		System.out.println(bank1 == bank2);

	}
}

//单例的饿汉式
class Bank{

	//1.私有化类的构造器
	private Bank(){

	}

	//2.内部创见类的对象
	//4.要求此对象也必须声明为静态的
	private static Bank instance = new Bank();

	//3.提供公共的静态的方法，返回类的对象。
	public static Bank getInstance(){
		return instance;
	}
}
```

> 2、**单例模式的懒汉式**

```java
/*
 * 单例的懒汉式实现
 *
 */
public class SingletonTest2 {
	public static void main(String[] args) {

		Order order1 = Order.getInstance();
		Order order2 = Order.getInstance();

		System.out.println(order1 == order2);
	}
}
class Order{
	//1.私有化类的构造器
	private Order(){

	}

	//2.声明当前类对象，没有初始化。
	//此对象也必须声明为 static 的
	private static Order instance = null;

	//3.声明 public、static 的返回当前类对象的方法
	public static Order getInstance(){
		if(instance == null){
			instance = new Order();
		}
		return instance;
	}
}
```

> 3、**单例模式的优点**

由于单例模式只生成一个实例，**减少了系统性能开销**，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/5b12c0fa376f3b691fe7b660b1d73baf.png)

> 4、单例(Singleton)设计模式-应用场景

*   **网站的计数器**，一般也是单例模式实现，否则难以同步。
*   **应用程序的日志应用**，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
*   **数据库连接池**的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
*   项目中，**读取配置文件的类**，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。
*   **Application**也是单例的典型应用
*   Windows 的 \*\*Task Manager (任务管理器)\*\*就是很典型的单例模式
*   Windows 的 \*\*Recycle Bin(回收站)\*\*也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。

## 18、理解 main 方法的语法（了解)

由于 Java 虚拟机需要调用类的 main()方法，所以该方法的访问权限必须是 public，又因为 Java 虚拟机在执行 main()方法时不必创建对象，所以该方法必须是 static 的，该方法接收一个 String 类型的数组参数，该数组中保存执行 Java 命令时传递给所运行的类的参数。

又因为 main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。

```java
/*
 * main()方法的使用说明
 * 1.main()方法作为程序的入口;
 * 2.main()方法也是一个普通的静态方法
 * 3.main()方法也可以作为我们与控制台交互的方式。(之前，使用 Scanner)
 *
 *
 */
public class MainTest {
	public static void main(String[] args) {	//入口

		Main.main(new String[100]);

		MainTest test = new MainTest();
		test.show();
	}

	public void show(){

	}
}

class Main{
	public static void main(String[] args) {
		args = new String[100];
		for(int i = 0;i < args.length;i++){
			args[i] = "args_" + i;
			System.out.println(args[i]);
		}
	}
}
```

> **命令行参数用法举例**

```java
public class MainDemo {
	public static void main(String[] args) {

		for(int i = 0;i < args.length;i++){
			System.out.println("/*/*/*/"+ args[i]);
		}
	}
}
```

> //运行程序 MainDemo.java

```java
javac MainDemo.java
java MainDemo “Tom” “Jerry” “Shkstart”
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/433e2dc60420147446a1954fc80dff97.png)

## 19、类的成员之四：代码块

```java
/*
 * 类的成员之四:代码块（或初始化块）
 *
 * 1.代码块的作用：用来初始化类、对象的
 * 2.代码块如果有修饰的话，只能使用 static
 * 3.分类:静态代码块 vs 非静态代码块
 *
 * 4.静态代码块
 * 	》内部可以有输出语句
 *  》随着类的加载而执行,而且只执行一次
 *  》作用:初始化类的信息
 *  》如果一个类中，定义了多个静态代码块，则按照声明的先后顺序执行
 *  》静态代码块的执行，优先于非静态代码块的执行
 *  》静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
 *
 * 5.非静态代码块
 *  >内部可以有输出语句
 *  >随着对象的创建而执行
 *  >每创建一个对象，就执行一次非静态代码块。
 *  >作用:可以在创建对象时，对对象的属性等进行初始化。
 *  >如果一个类中，定义了多个非静态代码块，则按照声明的先后顺序执行
 *  >非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法。
 *
 * 对属性可以赋值的位置:
 *  ①默认初始化
 *  ②显式初始化
 *  ③构造器中初始化
 *  ④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值。
 *  ⑤在代码块中赋值
 */
public class BlockTest {
	public static void main(String[] args) {

		String desc = Person.desc;
		System.out.println(desc);

		Person p1 = new Person();
		Person p2 = new Person();
		System.out.println(p1.age);

		Person.info();
	}
}

class Person{
	//属性
	String name;
	int age;
	static String desc = "我是一个青年";

	//构造器
	public Person(){

	}

	//static 的代码块
	static{
		System.out.println("hello,static block-1");
		//调用静态结构
		desc = "我是一个爱小说的人";
		info();
		//不能调用非静态结构
//		eat();
//		name = "Tom";
	}

	static{
		System.out.println("hello,static block-2");
	}

	//非 static 的代码块
	{
		System.out.println("hello,block-2");
	}
	{
		System.out.println("hello,block-1");
		//调用非静态结构
		age = 1;
		eat();
		//调用静态结构
		desc = "我是一个爱小说的人 1";
		info();
	}

	//方法
	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}

	public void eat(){
		System.out.println("吃饭");
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
	public static void info(){
		System.out.println("我是一个快乐的人。");
	}

}
```

> **静态初始化块举例 1**

```java
//总结:由父类到子类，静态先行
class Root{
	static{
		System.out.println("Root 的静态初始化块");
	}
	{
		System.out.println("Root 的普通初始化块");
	}
	public Root(){
		System.out.println("Root 的无参数的构造器");
	}
}
class Mid extends Root{
	static{
		System.out.println("Mid 的静态初始化块");
	}
	{
		System.out.println("Mid 的普通初始化块");
	}
	public Mid(){
		System.out.println("Mid 的无参数的构造器");
	}
	public Mid(String msg){
		//通过 this 调用同一类中重载的构造器
		this();
		System.out.println("Mid 的带参数构造器，其参数值："
			+ msg);
	}
}
class Leaf extends Mid{
	static{
		System.out.println("Leaf 的静态初始化块");
	}
	{
		System.out.println("Leaf 的普通初始化块");
	}
	public Leaf(){
		//通过 super 调用父类中有一个字符串参数的构造器
		super("尚硅谷");
		System.out.println("Leaf 的构造器");
	}
}
public class LeafTest{
	public static void main(String[] args){
		new Leaf();
		//new Leaf();
	}
}
```

> **静态初始化块举例 2**

```java
class Father {
	static {
		System.out.println("11111111111");
	}
	{
		System.out.println("22222222222");
	}

	public Father() {
		System.out.println("33333333333");

	}

}

public class Son extends Father {
	static {
		System.out.println("44444444444");
	}
	{
		System.out.println("55555555555");
	}
	public Son() {
		System.out.println("66666666666");
	}

	public static void main(String[] args) { // 由父及子 静态先行
		System.out.println("77777777777");
		System.out.println("************************");
		new Son();
		System.out.println("************************");

		new Son();
		System.out.println("************************");
		new Father();
	}

}
```

> **总结：程序中成员变量赋值的执行顺序**

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/35c39171e6d8d7a2a25bd0c9edd48ee9.png)

```java
/*
 * 对属性可以赋值的位置:
 *  ①默认初始化
 *  ②显式初始化 / ⑤在代码块中赋值
 *  ③构造器中初始化
 *  ④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值。
 *
 *  执行的先后顺序:① - ② / ⑤ - ③ - ④
 */
public class OrderTest {
	public static void main(String[] args) {
		Order order = new Order();
		System.out.println(order.orderId);
	}
}
class Order{

	int orderId = 3;
	{
		orderId = 4;
	}

}
```

## 20、关键字：final

```java
/*
 * final:最终的
 *
 * 1.final可以用来修饰的结构:类、方法、变量
 *
 * 2.final用来修饰一个类:此类不能被其他类所继承。
 * 		  比如:String类、System类、StringBuffer类
 * 3.final修饰一个方法:final标记的方法不能被子类重写。
 * 		  比如：Object类中的getClass()。
 * 4.final用来修饰变量:此时的"变量"(成员变量或局部变量)就是一个常量。名称大写，且只能被赋值一次。
 * 	 4.1 final修饰属性，可以考虑赋值的位置有:显式初始化、代码块中初始化、构造器中初始化
 *   4.2 final修饰局部变量:
 *   	 尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。
 *      一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
 *
 * static final 用来修饰:全局常量
 */
public class FinalTest {

	final int WIDTH = 0;
	final int LEFT;
	final int RIGHT;
//	final int DOWN;

	{
		LEFT = 1;
	}

	public FinalTest(){
		RIGHT = 2;
	}

	public FinalTest(int n){
		RIGHT = n;
	}

//	public void setDown(int down){
//		this.DOWN = down;
//	}

	public void dowidth(){
//		width = 20;	//width cannot be resolved to a variable
	}

	public void show(){
		final int NUM = 10;	//常量
//		num += 20;
	}

	public void show(final int num){
		System.out.println(num);
	}

	public static void main(String[] args) {

		int num = 10;

		num = num + 5;

		FinalTest test = new FinalTest();
//		test.setDown(5);

		test.show(10);
	}
}

final class FianlA{

}

//class B extends FinalA{     //错误，不能被继承。
//
//}

//class C extends String{
//
//}

class AA{
	public final void show(){

	}
}

//class BB extends AA{	// 错误，不能被重写。
//	public void show(){
//
//	}
//}
```

> 1、**面试题1**

```java
public class Something {
	public int addOne(final int x) {
		return ++x; // return x + 1;
	}
}
```

> 2、**面试题2**

```java
public class Something {

	public static void main(String[] args) {
		Other o = new Other();
		new Something().addOne(o);
	}

	public void addOne(final Other o) {
		// o = new Other();
		o.i++;
	}
}

class Other {
	public int i;
}
```

## 21、抽象类与抽象方法

随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做**抽象类**。

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/367a5bc4e1045fec15a665827ad1a665.png)

```java
/*
 * abstract 关键字的使用
 *
 * 1.abstract:抽象的
 * 2.abstract 可以用来修饰的结构:类、方法
 * 3.abstract 修饰类:抽象类
 * 	》 此类不能实例化
 *  》 抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化全过程)
 *  》 开发中，都会提供抽象类的子类，让子类对象实例化，实现相关的操作
 *
 * 4.abstract 修饰方法:抽象方法
 *  > 抽象方法，只有方法的声明，没有方法体。
 *  > 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法
 *  > 若子类重写了父类中所有的抽象方法，此子类，
 *
 * abstract 使用上的注意点:
 * 1.abstract 不能用来修饰变量、代码块、构造器；
 *
 * 2.abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类。
 *
 */
public class AbstractTest {
	public static void main(String[] args) {
		//一旦 Person 类抽象了，就不可实例化
//		Person p1 = new Person();
//		p1.eat();

	}
}

abstract class Creature{
	public abstract void breath();
}

abstract class Person extends Creature{
	String name;
	int age;

	public Person(){

	}

	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}

	//不是抽象方法
//	public void eat(){
//		System.out.println("人吃饭");
//	}

	//抽象方法
	public abstract void eat();

	public void walk(){
		System.out.println("人走路");
	}
}

class Student extends Person{
	public Student(String name,int age){
		super(name,age);
	}
	public void eat(){
		System.out.println("学生应该多吃有营养的。");
	}
	@Override
	public void breath() {
		System.out.println("学生应该呼吸新鲜的无雾霾空气");
	}
}
```

### 5.1、抽象类应用

> 抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/fae4ad700aef40c0402a7e092da91106.png)

> 问题：卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle 类不能提供计算方法，但子类可以。

```java
/* Java 允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提  供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。
 * Vehicle 是一个抽象类，有两个抽象方法。
 * 注意：抽象类不能实例化 new Vihicle()是非法的
 */
public abstract class Vehicle{
	public abstract double calcFuelEfficiency();//计算燃料效率的抽象方法
	public abstract double calcTripDistance();//计算行驶距离的抽象方法
}
public class Truck extends Vehicle{
	public double calcFuelEfficiency(){
		//写出计算卡车的燃料效率的具体方法
	}
	public double calcTripDistance(){
		//写出计算卡车行驶距离的具体方法
	}
}
public class RiverBarge extends Vehicle{
	public double calcFuelEfficiency() {
		//写出计算驳船的燃料效率的具体方法
	}
	public double calcTripDistance( )  {
		//写出计算驳船行驶距离的具体方法
	}
}
```

### 5.2、练习

```java
/*
 * 编写一个 Employee 类，声明为抽象类，
 * 包含如下三个属性：name，id，salary。
 * 提供必要的构造器和抽象方法：work()。
 * 对于 Manager 类来说，他既是员工，还具有奖金(bonus)的属性。
 * 请使用继承的思想，设计 CommonEmployee 类和 Manager 类，
 * 要求类中提供必要的方法进行属性访问。
 *
 */
public abstract class Employee {

	private String name;
	private int id;
	private double salary;

	public Employee(){
		super();
	}

	public Employee(String name, int id, double salary) {
		super();
		this.name = name;
		this.id = id;
		this.salary = salary;
	}

	public abstract void work();
}
```

> Manager 类

```java
/*
 * 对于 Manager 类来说，他既是员工，还具有奖金(bonus)的属性。
 *
 */
public class Manager extends Employee{

	private double bonus;	//奖金

	public Manager(double bonus) {
		super();
		this.bonus = bonus;
	}

	public Manager(String name, int id, double salary, double bonus) {
		super(name, id, salary);
		this.bonus = bonus;
	}

	@Override
	public void work() {
		System.out.println("管理员工，提高公司运行效率。");
	}
}
```

> CommonEmployee 类

```java
public class CommonEmployee extends Employee {

	@Override
	public void work() {
		System.out.println("员工在一线车间生产产品。");
	}

}
```

> 测试类

```java
/*
 * 请使用继承的思想，设计 CommonEmployee 类和 Manager 类，
 */
public class EmployeeTest {
	public static void main(String[] args) {

		Employee manager = new Manager("库克",1001,5000,50000);

		manager.work();

		CommonEmployee commonEmployee = new CommonEmployee();
		commonEmployee.work();
	}
}
```

### 5.3、创建抽象类的匿名子类对象

```java
public class Num {

}

abstract class Creature{
	public abstract void breath();
}

abstract class Person extends Creature{
	String name;
	int age;

	public Person(){

	}

	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}

	//不是抽象方法
//	public void eat(){
//		System.out.println("人吃饭");
//	}

	//抽象方法
	public abstract void eat();

	public void walk(){
		System.out.println("人走路");
	}
}

class Student extends Person{
	public Student(String name,int age){
		super(name,age);
	}
	public Student(){

	}
	public void eat(){
		System.out.println("学生应该多吃有营养的。");
	}
	@Override
	public void breath() {
		System.out.println("学生应该呼吸新鲜的无雾霾空气");
	}
}
```

> PersonTest 类

```java
/*
 * 抽象类的匿名子类
 *
 */
public class PersonTest {
	public static void main(String[] args) {

		method(new Student());	//匿名对象

		Worker worker = new Worker();
		method1(worker);	//非匿名的类非匿名的对象

		method1(new Worker());	//非匿名的类匿名的对象

		System.out.println("*********************");

		//创建了一个匿名子类的对象:p
		Person p = new Person(){

			@Override
			public void eat() {
				System.out.println("吃东西");
			}

			@Override
			public void breath() {
				System.out.println("呼吸空气");
			}

		};
		method1(p);
		System.out.println("**********************");
		//创建匿名子类的匿名对象
		method1(new Person(){

			@Override
			public void eat() {
				System.out.println("吃零食");
			}

			@Override
			public void breath() {
				System.out.println("云南的空气");
			}

		});
	}

	public static void method1(Person p){
		p.eat();
		p.walk();
	}

	public static void method(Student s){

	}
}
class Worker extends Person{

	@Override
	public void eat() {
	}

	@Override
	public void breath() {
	}
}
```

### 5.4、多态的应用：模板方法设计模式(TemplateMethod)

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

> 解决的问题：

当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
换句话说，**在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。**

> 1、例 1

```java
/*
 * 抽象类的应用:模板方法的设计模式
 */
public class TemplateTest {
	public static void main(String[] args) {

		SubTemlate t = new SubTemlate();

		t.sendTime();
	}
}
abstract class Template{

	//计算某段代码执行所需花费的时间
	public void sendTime(){

		long start = System.currentTimeMillis();

		code();	//不确定部分，易变的部分

		long end = System.currentTimeMillis();

		System.out.println("花费的时间为:" + (end - start));
	}

	public abstract void code();
}

class SubTemlate extends Template{

	@Override
	public void code() {

		for(int i = 2;i <= 1000;i++){
			boolean isFlag = true;
			for(int j = 2;j <= Math.sqrt(i);j++){
				if(i % j == 0){
					isFlag = false;
					break;
				}
			}
			if(isFlag){
				System.out.println(i);
			}
		}
	}
}
```

> 2、例 2

```java
//抽象类的应用：模板方法的设计模式
public class TemplateMethodTest {

	public static void main(String[] args) {
		BankTemplateMethod btm = new DrawMoney();
		btm.process();

		BankTemplateMethod btm2 = new ManageMoney();
		btm2.process();
	}
}
abstract class BankTemplateMethod {
	// 具体方法
	public void takeNumber() {
		System.out.println("取号排队");
	}

	public abstract void transact(); // 办理具体的业务 //钩子方法

	public void evaluate() {
		System.out.println("反馈评分");
	}

	// 模板方法，把基本操作组合到一起，子类一般不能重写
	public final void process() {
		this.takeNumber();

		this.transact();// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码

		this.evaluate();
	}
}

class DrawMoney extends BankTemplateMethod {
	public void transact() {
		System.out.println("我要取款！！！");
	}
}

class ManageMoney extends BankTemplateMethod {
	public void transact() {
		System.out.println("我要理财！我这里有 2000 万美元!!");
	}
}
```

> 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：

*   数据库访问的封装
*   Junit 单元测试
*   JavaWeb 的 Servlet 中关于 doGet/doPost 方法调用
*   Hibernate 中模板程序
*   Spring 中 JDBCTemlate、HibernateTemplate 等

### 5.5、抽象类的练习

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/a36e51e665b20673f270cb9b2b921e20.png)
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/56ace48e046b22da15db7100a2edfccb.png)

> 1、Employee 类

```java
/*
 * 定义一个 Employee 类，
 * 该类包含：private 成员变量 name,number,birthday，
 * 其中 birthday 为 MyDate 类的对象；
 * abstract 方法 earnings()；
 * toString()方法输出对象的 name,number 和 birthday。
 *
 */
public abstract class Employee {
	private String name;
	private int number;
	private MyDate birthday;

	public Employee(String name, int number, MyDate birthday) {
		super();
		this.name = name;
		this.number = number;
		this.birthday = birthday;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getNumber() {
		return number;
	}

	public void setNumber(int number) {
		this.number = number;
	}

	public MyDate getBirthday() {
		return birthday;
	}

	public void setBirthday(MyDate birthday) {
		this.birthday = birthday;
	}

	public abstract double earnings();

	@Override
	public String toString() {
		return "name=" + name + ", number=" + number + ", birthday=" + birthday.toDateString() + "]";
	}

}
```

> 2、MyDate 类

```java
/*
 * MyDate 类包含:private 成员变量 year,month,day；
 * toDateString()方法返回日期对应的字符串：xxxx 年 xx 月 xx 日
 */
public class MyDate {
	private int year;
	private int month;
	private int day;

	public MyDate(int year, int month, int day) {
		super();
		this.year = year;
		this.month = month;
		this.day = day;
	}

	public int getYear() {
		return year;
	}

	public void setYear(int year) {
		this.year = year;
	}

	public int getMonth() {
		return month;
	}

	public void setMonth(int month) {
		this.month = month;
	}

	public int getDay() {
		return day;
	}

	public void setDay(int day) {
		this.day = day;
	}

	public String toDateString(){
		return year + "年" + month + "月" + day + "日";
	}
}
```

> 3、SalariedEmployee 类

```java
/*
 * 定义 SalariedEmployee 类继承 Employee 类，实现按月计算工资的员工处理。
 * 该类包括：private 成员变量 monthlySalary；实现父类的抽象方法 earnings(),
 * 该方法返回 monthlySalary 值；
 * toString()方法输出员工类型信息及员工的 name，number,birthday。
 *
 */
public class SalariedEmployee extends Employee{
	private double monthlySalary;	//月工资

	public SalariedEmployee(String name,int number,MyDate birthday) {
		super(name,number,birthday);
	}

	public SalariedEmployee(String name, int number, MyDate birthday, double monthlySalary) {
		super(name, number, birthday);
		this.monthlySalary = monthlySalary;
	}

	@Override
	public double earnings() {
		return monthlySalary;
	}

	@Override
	public String toString() {
		return "SalariedEmployee [" + super.toString() + "]";
	}
}
```

> 4、HourlyEmployee 类

```java
/*
 * 参照 SalariedEmployee 类定义 HourlyEmployee 类，
 * 实现按小时计算工资的员工处理。该类包括：private 成员变量 wage 和 hour；
 * 实现父类的抽象方法 earnings(),该方法返回 wage*hour 值；
 * toString()方法输出员工类型信息及员工的 name，number,birthday。
 *
 */
public class HourlyEmployee extends Employee{
	private int wage;	//每小时的工资
	private int hour;	//月工作的小时数

	public HourlyEmployee(String name, int number, MyDate birthday) {
		super(name, number, birthday);
	}

	public HourlyEmployee(String name, int number, MyDate birthday, int wage, int hour) {
		super(name, number, birthday);
		this.wage = wage;
		this.hour = hour;
	}

	@Override
	public double earnings() {
		return wage*hour;
	}

	public int getWage() {
		return wage;
	}

	public void setWage(int wage) {
		this.wage = wage;
	}

	public int getHour() {
		return hour;
	}

	public void setHour(int hour) {
		this.hour = hour;
	}

	public String toString(){
		return "HourlyEmployee[" + super.toString() + "]";
	}
}
```

> 5、PayrollSystem 类

```java
import java.util.Calendar;
import java.util.Scanner;
/*
 * 定义 PayrollSystem 类，创建 Employee 变量数组并初始化，
 * 该数组存放各类雇员对象的引用。利用循环结构遍历数组元素，
 * 输出各个对象的类型,name,number,birthday,以及该对象生日。
 * 当键盘输入本月月份值时，
 * 如果本月是某个 Employee 对象的生日，还要输出增加工资信息。
 *
 */
public class PayrollSystem {
	public static void main(String[] args) {
		//方式一：
//		Scanner scanner = new Scanner(System.in);
//		System.out.println("请输入当月的月份：");
//		int month = scanner.nextInt();

		//方式二：
		Calendar calendar = Calendar.getInstance();
		int month = calendar.get(Calendar.MONTH);//获取当前的月份
//		System.out.println(month);//一月份：0

		Employee[] emps = new Employee[2];

		emps[0] = new SalariedEmployee("马良", 1002,new MyDate(1992, 2, 28),10000);
		emps[1] = new HourlyEmployee("博西", 2001, new MyDate(1991, 1, 6),60,240);

		for(int i = 0;i < emps.length;i++){
			System.out.println(emps[i]);
			double salary = emps[i].earnings();
			System.out.println("月工资为：" + salary);

			if((month+1) == emps[i].getBirthday().getMonth()){
				System.out.println("生日快乐！奖励 100 元");
			}

		}
	}
}
```

## 22、接口(interface)

### 6.1、概述

一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。

另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有 is-a 的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3 机、手机、数码相机、移动硬盘等都支持 USB 连接。

接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。**继承是一个"是不是"的关系，而接口实现则是"能不能"的关系。**

**接口的本质是契约，标准，规范**，就像我们的法律一样。制定好后大家都要遵守。
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/aec8823d72652f568ac820b927069e4e.png)

```java
/* 接口(interface)是抽象方法和常量值定义的集合。
 * 接口的特点：
 * 用 interface 来定义。
 * 接口中的所有成员变量都默认是由 public static final 修饰的。
 * 接口中的所有抽象方法都默认是由 public abstract 修饰的。
 * 接口中没有构造器。
 * 接口采用多继承机制。
 */
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/729b5a0b77e2881568a2c029920e0f2e.png)

```java
/*
 * 接口的使用
 * 1.接口使用 interface 来定义。
 * 2.在 Java 中:接口和类是并列的两个结构
 * 3.如何去定义两个接口:定义接口中的成员
 * 	》3.1 JDK7 及以前:只能定义全局常量和抽象方法
 * 		》全局常量:public static final 的,但是书写中，可以省略不写。
 * 		》抽象方法:public abstract 的
 *
 *  》3.2 JDK8:除了全局常量和抽象方法之外，还可以定义静态方法、默认方法(略)。
 *
 * 4.接口中不能定义构造器！意味着接口不可以实例化。
 *
 * 5.Java 开发中，接口通过让类去实现(implements)的方式来使用。
 *   如果实现类覆盖了接口中的所有方法，则此实现类就可以实例化
 *   如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
 *
 * 6.Java 类可以实现多个接口 ---》弥补了 Java 单继承性的局限性
 *  格式:class AA extends BB implementd CC,DD,EE
 *
 *  7.接口与接口之间是继承,而且可以多继承
 *
 **********************************
 * 8.接口的具体使用，体现多态性
 * 	   接口的主要用途就是被实现类实现。（面向接口编程）
 * 9.接口，实际可以看作是一种规范
 *
 * 面试题:抽象类与接口有哪些异同？
 *
 */
public class InterfaceTest {
	public static void main(String[] args) {
		System.out.println(Flayable.MAX_SPEED);
		System.out.println(Flayable.MIN_SPEED);
	}
}
interface Flayable{

	//全局变量
	public static final int MAX_SPEED = 7900;
	int MIN_SPEED = 1;//省略了 public static final

	//抽象方法
	public abstract void fly();

	void stop();//省略了 public abstract
	//Interfaces cannot have constructors
//	public Flayable(){
//
//	}
}
interface Attackable{
	void attack();
}

class Plane implements Flayable{

	@Override
	public void fly() {
		System.out.println("飞机通过引擎起飞");

	}

	@Override
	public void stop() {
		System.out.println("驾驶员减速停止");
	}

}
abstract class Kite implements Flayable{

	@Override
	public void fly() {

	}
}

class Bullet extends Object implements Flayable,Attackable,CC{

	@Override
	public void attack() {
		// TODO Auto-generated method stub

	}

	@Override
	public void fly() {
		// TODO Auto-generated method stub

	}

	@Override
	public void stop() {
		// TODO Auto-generated method stub

	}

	@Override
	public void method1() {
		// TODO Auto-generated method stub

	}

	@Override
	public void method2() {
		// TODO Auto-generated method stub

	}
}

//*********************************
interface AA{
	void method1();
}
interface BB{
	void method2();
}
interface CC extends AA,BB{

}
```

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/1c9cab10d5aac0ca205e787df6f7bed2.png)
![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/e0c3ab2a9f72d5c2aaaca773adc0017d.png)

### 6.2、举例

```java
/*
 * 接口的使用
 * 1.接口使用上也满足多态性
 * 2.接口，实际上就是定义了一种规范
 * 3.开发中，体会面向接口编程！
 *
 */
public class USBTest {
	public static void main(String[] args) {

		Computer com = new Computer();
		//1.创建了接口的非匿名实现类的非匿名对象
		Flash flash = new Flash();
		com.transferData(flash);
		//2. 创建了接口的非匿名实现类的匿名对象
		com.transferData(new Printer());
		//3. 创建了接口的匿名实现类的非匿名对象
		USB phone = new USB(){

			@Override
			public void start() {
				System.out.println("手机开始工作");
			}

			@Override
			public void stop() {
				System.out.println("手机结束工作");
			}

		};
		com.transferData(phone);
		//4. 创建了接口的匿名实现类的匿名对象
		com.transferData(new USB(){
			@Override
			public void start() {
				System.out.println("mp3 开始工作");
			}

			@Override
			public void stop() {
				System.out.println("mp3 结束工作");
			}
		});
	}
}

class Computer{

	public void transferData(USB usb){//USB usb = new Flash();
		usb.start();

		System.out.println("具体传输数据的细节");

		usb.stop();
	}

}

interface USB{
	//常量:定义了长、宽
	void start();

	void stop();
}
class Flash implements USB{

	@Override
	public void start() {
		System.out.println("U 盘开始工作");
	}

	@Override
	public void stop() {
		System.out.println("U 盘结束工作");
	}
}
class Printer implements USB{
	@Override
	public void start() {
		System.out.println("打印机开启工作");
	}

	@Override
	public void stop() {
		System.out.println("打印机结束工作");
	}

}
```

### 6.3、接口的应用：代理模式(Proxy)

代理模式是 Java 开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/6be3acfe541841343c9338f669a58d0c.png)

```java
/*
 * 接口的应用:代理模式
 *
 *
 */
public class NetWorkTest {
	public static void main(String[] args) {

		Server server = new Server();
//		server.browse();
		ProxyServer proxyServer = new ProxyServer(server);

		proxyServer.browse();
	}
}
interface NetWork{
	public void browse();

}
//被代理类
class Server implements NetWork{

	@Override
	public void browse() {
		System.out.println("真实的服务器来访问网络");
	}
}
//代理类
class ProxyServer implements NetWork{

	private NetWork work;

	public ProxyServer(NetWork work){
		this.work = work;
	}

	public void check(){
		System.out.println("联网前的检查工作");
	}

	@Override
	public void browse() {
		check();

		work.browse();
	}

}
```

> 应用场景：

*   安全代理：屏蔽对真实角色的直接访问。
*   远程代理：通过代理类处理远程方法调用（RMI）
*   延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象

比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用 proxy 来进行大图片的打开。

> 分类

*   静态代理（静态定义代理类）
*   动态代理（动态生成代理类）
    *   JDK 自带的动态代理，需要反射等知识

```java
public class StaticProxyTest {

	public static void main(String[] args) {
		Proxy s = new Proxy(new RealStar());
		s.confer();
		s.signContract();
		s.bookTicket();
		s.sing();
		s.collectMoney();
	}
}

interface Star {
	void confer();// 面谈

	void signContract();// 签合同

	void bookTicket();// 订票

	void sing();// 唱歌

	void collectMoney();// 收钱
}
//被代理类
class RealStar implements Star {

	public void confer() {
	}

	public void signContract() {
	}

	public void bookTicket() {
	}

	public void sing() {
		System.out.println("明星：歌唱~~~");
	}

	public void collectMoney() {
	}
}

//代理类
class Proxy implements Star {
	private Star real;

	public Proxy(Star real) {
		this.real = real;
	}

	public void confer() {
		System.out.println("经纪人面谈");
	}

	public void signContract() {
		System.out.println("经纪人签合同");
	}

	public void bookTicket() {
		System.out.println("经纪人订票");
	}

	public void sing() {
		real.sing();
	}

	public void collectMoney() {
		System.out.println("经纪人收钱");
	}
}
```

### 6.4、接口的应用：工厂模式

拓展：[工厂设计模式.pdf](https://www.yuque.com/nizhegechouloudetuboshu/library/mlenxx)

> 接口和抽象类之间的对比

No.区别点抽象类接口1定义包含抽象方法的类主要是抽象方法和全局常量的集合2组成构造方法、抽象方法、普通方法、常量、变量常量、抽象方法、(jdk8.0:默认方法、静态方法)3使用子类继承抽象类(extends)子类实现接口(implements)4关系抽象类可以实现多个接口接口不能继承抽象类，但允许继承多个接口5常见设计模式模板方法简单工厂、工厂方法、代理模式6对象都通过对象的多态性产生实例化对象7局限抽象类有单继承的局限接口没有此局限8实际作为一个模板是作为一个标准或是表示一种能力9选择如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限

> 在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。
> \-【面试题】排错：

```java
interface A {
	int x = 0;
}
class B {
	int x = 1;
}
class C extends B implements A {
	public void pX() {
//		编译不通过，x 不明确
		System.out.println(x);
//		System.out.println(super.x); //1
//		System.out.println(A.x);//0
	}
	public static void main(String[] args) {
		new C().pX();
	}
}
```

> 排错 2：

```java
interface Playable {
	void play();
}
interface Bounceable {
	void play();
}
interface Rollable extends Playable, Bounceable {
	Ball ball= new Ball("PingPang"); //省略了 public static final
}
public class Ball implements Rollable {
	private String name;
	public String getName() {
		return name;
	}
	public Ball(String name) {
		this.name= name;
	}
	public void play() {
		ball = new Ball("Football"); //The final field Rollable.ball cannot be assigned
		System.out.println(ball.getName());
	}
}
```

> 练习

![](https://cdn.jsdelivr.net/gh/9acme/assets@note/javase/6593e549625053470aca56f338387d98.png)

CompareObject 类

```java
/*
 * 定义一个接口用来实现两个对象的比较。
 *
 */
public interface CompareObject {
	public int compareTo(Object o);
	//若返回值是 0,代表相等;若为正数，代表当前对象大；负数代表当前对象小

}
```

Circle 类

```java
/*
 * 定义一个 Circle 类，声明 redius 属性，提供 getter 和 setter 方法
 */
public class Circle {

	private Double radius;

	public Double getRadius() {
		return radius;
	}

	public void setRadius(Double radius) {
		this.radius = radius;
	}

	public Circle() {
		super();
	}

	public Circle(Double radius) {
		super();
		this.radius = radius;
	}

}
```

ComparableCircle 类

```java
/*
 * 定义一个 ComparableCircle 类，继承 Circle 类并且实现 CompareObject 接口。在 ComparableCircle 类中给出接口中方法 compareTo 的实现体，
 * 用来比较两个圆的半径大小。
 */
public class ComparableCircle extends Circle implements CompareObject{

	public ComparableCircle(double radius) {
		super(radius);
	}
	@Override
	public int compareTo(Object o) {
		if(this == o){
			return 0;
		}
		if(o instanceof ComparableCircle){
			ComparableCircle c = (ComparableCircle)o;
			//错误的写法
//			return (int)(this.getRedius() - c.getRedius());
			//正确的方式一：
//			if(this.getRadius() > c.getRadius()){
//				return 1;
//			}else if(this.getRadius() < c.getRadius()){
//				return -1;
//			}else{
//				return 0;
//			}
			//当属性 radius 声明为 Double 类型时，可以调用包装类的方法
			//正确的方式二：
			return this.getRadius().compareTo(c.getRadius());
		}else{
			return 0;
//			throw new RuntimeException("传入数据类型不匹配");
		}
	}
}
```

InterfaceTest 类

```java
/*
 * 定义一个测试类 InterfaceTest，创建两个 ComparableCircle 对象，
 * 调用 compareTo 方法比较两个类的半径大小。
 *
 */
public class InterfaceTest {
	public static void main(String[] args) {

		ComparableCircle c1 = new ComparableCircle(3.4);
		ComparableCircle c2 = new ComparableCircle(3.6);

		int compareValue = c1.compareTo(c2);
		if(compareValue > 0){
			System.out.println("c1 对象大");
		}else if(compareValue < 0){
			System.out.println("c2 对象大");
		}else{
			System.out.println("两个一样的");
		}

		int compareValue1 = c1.compareTo(new String("AA"));
		System.out.println(compareValue1);
	}
}
```

## 23、Java 8 中关于接口的改进

Java 8 中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。

> 静态方法：

使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像 Collection/Collections 或者 Path/Paths 这样成对的接口和类。

> 默认方法：

默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API 中对 Collection、List、Comparator 等接口提供了丰富的默认方法。

> 例1

interface 类

```java
/*
 * JDK8:除了全局常量和抽象方法之外，还可以定义静态方法、默认方法(略)。
 *
 *
 */
public interface CompareA {

	//静态方法
	public static void method1() {
		System.out.println("CompareA:西安");
	}

	//默认方法
	public default void method2(){
		System.out.println("CompareA:深圳");
	}

	default void method3(){
		System.out.println("CompareA:杭州");
	}
}
```

SubClassTest 类

```java
public class SubClassTest {

	public static void main(String[] args) {
		SubClass s = new SubClass();
//		s.method1();
//		SubClass.method1();
//		知识点 1：接口中定义的静态方法，只能通过接口来调用。
		CompareA.method1();
//		知识点 2：通过实现类的对象，可以调用接口中的默认方法。
//		如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
		s.method2();
//		知识点 3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，
//		那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则
//		知识点 4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，
//		那么在实现类没有重写此方法的情况下，报错。-->接口冲突。
//		这就需要我们必须在实现类中重写此方法
		s.method3();

	}
}
class SubClass extends SuperClass implements CompareA,CompareB{

	public void method2(){
		System.out.println("SubClass：上海");
	}

	public void method3(){
		System.out.println("SubClass：深圳");
	}

//	知识点 5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法
	public void myMethod(){
		method3(); //调用自己定义的重写的方法
		super.method3(); //调用的是父类中声明的
//		调用接口中的默认方法
		CompareA.super.method3();
		CompareB.super.method3();
	}
}
```

SuperClass 类

```java
public class SuperClass {
	public void method3(){
		System.out.println("SuperClass:北京");
	}
}
```

CompareB 类

```java
public interface CompareB {
	default void method3(){
		System.out.println("CompareB：上海");
	}
}
```

> 例2

```java
/*
 * 练习：接口冲突的解决方式
 */
interface Filial {// 孝顺的
	default void help() {
		System.out.println("老妈，我来救你了");
	}
}

interface Spoony {// 痴情的
	default void help() {
		System.out.println("媳妇，别怕，我来了");
	}
}

class Father{
	public void help(){
		System.out.println("儿子，救我媳妇！");
	}
}

class Man extends Father implements Filial, Spoony {

	@Override
	public void help() {
		System.out.println("我该就谁呢？");
		Filial.super.help();
		Spoony.super.help();
	}

}
```

## 24、类的内部成员之五：内部类

当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。

```java
/*
 * 类的内部成员之五:内部类
 *
 * 1.Java中允许将一个类A声明在另一个类B中,则类A就是内部类,类B就是外部类.
 *
 * 2.内部类的分类:成员内部类	VS	局部内部类(方法内、代码块内、构造器内)
 *
 * 3.成员内部类
 * 	》作为外部类的成员,
 * 		- 调用外部类的结构
 * 		- 可以被static修饰
 * 		- 可以被4种不同的权限修饰
 *
 *  》作为一个类，
 *  	- 类内可以定义属性、方法、构造器等
 *  	- 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
 *  	- 可以abstract修饰
 *
 * 4.关注如下的3个问题
 *   》 如何实例化成员内部类的对象
 *   》 如何在成员内部类中区分调用外部类的结构
 *   》 开发中局部内部类的使用  见《InnerClassTest1.java》
 */
public class InnerClassTest {
	public static void main(String[] args) {

		//创建Dog实例(静态的成员内部类)
		Person.Dog dog = new Person.Dog();
		dog.show();

		//创建Bird实例(非静态的成员内部类)
//		Person.Bird bird = new Person.Bird();
		Person p = new Person();
		Person.Bird bird = p.new Bird();
		bird.sing();

		System.out.println();

		bird.display("喜鹊");
	}
}
class Person{
	String name = "李雷";
	int age;

	public void eat(){
		System.out.println("人，吃饭");
	}

	//静态成员内部类
	static class Dog{
		String name;
		int age;

		public void show(){
			System.out.println("卡拉是条狗");
//			eat();
		}
	}

	//非静态成员内部类
	class Bird{
		String name = "杜鹃";
		public Bird(){

		}

		public void sing(){
			System.out.println("我是一只猫头鹰");
			Person.this.eat();//调用外部类的非静态属性
			eat();
			System.out.println(age);
		}

		public void display(String name){
			System.out.println(name);	//方法的形参
			System.out.println(this.name);	//内部类的属性
			System.out.println(Person.this.name);	//外部类的属性
		}
	}
	public void method(){
		//局部内部类
		class AA{

		}
	}

	{
		//局部内部类
		class BB{

		}
	}

	public Person(){
		//局部内部类
		class CC{

		}
	}
}
```

> InnerClassTest1类

```java
public class InnerClassTest1 {

//	开发中很少见
	public void method(){
//		局部内部类
		class AA{

		}
	}

//	返回一个实现了Comparable接口的类的对象
	public Comparable getComparable(){

//		创建一个实现了Comparable接口的类:局部内部类
		//方式一：
//		class MyComparable implements Comparable{
//
//			@Override
//			public int compareTo(Object o) {
//				return 0;
//			}
//
//		}
//
//		return new MyComparable();

		//方式二：
		return new Comparable(){

			@Override
			public int compareTo(Object o) {
				return 0;
			}

		};

	}
}
```

### 8.1、匿名内部类

```java
/*
 * 1.匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。
 * 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。
 *
 * 2.格式：
 * 		new 父类构造器（实参列表）|实现接口(){
 * 				//匿名内部类的类体部分
 * 		}
 *
 * 3.匿名内部类的特点
 * 		> 匿名内部类必须继承父类或实现接口
 * 		> 匿名内部类只能有一个对象
 * 		> 匿名内部类对象只能使用多态形式引用
 */
interface Product{
	public double getPrice();
	public String getName();
}
public class AnonymousTest{
	public void test(Product p){
		System.out.println("购买了一个" + p.getName() + "，花掉了" + p.getPrice());
	}
	public static void main(String[] args) {
		AnonymousTest ta = new AnonymousTest();
		//调用test方法时，需要传入一个Product参数，
		//此处传入其匿名实现类的实例
		ta.test(new Product(){
			public double getPrice(){
				return 567.8;
			}
			public String getName(){
				return "AGP显卡";
			}
		});
	}
}
```

### 8.2、局部内部类的使用注意

```java
public class InnerClassTest {

//	public void onCreate(){
//
//	int number = 10;
//
//	View.OnClickListern listener = new View.OnClickListener(){
//
//		public void onClick(){
//			System.out.println("hello!");
//			System.out.println(number);
//		}
//
//	}
//
//	button.setOnClickListener(listener);
//
//}

	/*
	 * 在局部内部类的方法中(比如:show)如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,
	 * 要求此局部变量声明为final的。
	 *
	 * jdk 7及之前版本：要求此局部变量显式的声明为final的
	 * jdk 8及之后的版本：可以省略final的声明
	 *
	 */
	public void method(){
		//局部变量
		int num = 10;

		class AA{

			public void show(){
//				num = 20;	//Local variable num defined in an enclosing scope must be final or effectively final
				System.out.println(num);
			}
		}
	}
}
```



